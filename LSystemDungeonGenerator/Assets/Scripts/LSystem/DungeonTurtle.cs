using System.Collections.Generic;
using UnityEngine;

namespace Didionysymus.DungeonGeneration.LSystem
{
    /// <summary>
    /// A turtle that walks through the L-system string
    /// and creates spatial dungeon data
    /// </summary>
    public class DungeonTurtle
    {
        private class TurtleState
        {
            public Vector2Int Position;
            public Direction Facing;
            public int FloorLevel;

            public TurtleState(Vector2Int position, Direction facing, int floorLevel)
            {
                Position = position;
                Facing = facing;
                FloorLevel = floorLevel;
            }
            
            public TurtleState Clone() => new TurtleState(Position, Facing, FloorLevel);
        }

        private TurtleState _currentState;
        private readonly Stack<TurtleState> _stateStack;
        private readonly DungeonConfig _config;
        private readonly LSystemGrammar _grammar;

        private int _roomIDCounter = 0;
        private int _currentFloor = 0;
        
        public Dictionary<Vector2Int, DungeonCell> Grid { get; private set; }
        public List<RoomData> Rooms { get; private set; }

        public DungeonTurtle(DungeonConfig config, LSystemGrammar grammar)
        {
            // Set parameters
            _config = config;
            _grammar = grammar;
            
            // Initialize data structures
            _stateStack = new Stack<TurtleState>();
            Grid = new Dictionary<Vector2Int, DungeonCell>();
            Rooms = new List<RoomData>();

            // Start at the center of the grid, facing north
            Vector2Int startPosition = _config.MaxGridSize / 2;
            _currentState = new TurtleState(startPosition, Direction.North, 0);
        }

        /// <summary>
        /// Interprets an L-system string and processes each symbol to construct the dungeon layout
        /// by following predefined dungeon generation rules
        /// </summary>
        /// <param name="lSystemString">
        /// The string generated by the L-system that encodes the sequence of actions for the turtle
        /// to perform, such as moving, turning, or creating dungeon structures.
        /// </param>
        public void Walkthrough(string lSystemString)
        {
            // Process each symbol in the string
            foreach (char symbol in lSystemString)
            {
                ProcessSymbol(symbol);
            }

            // After interpretation, build walls
            BuildWalls();
        }

        /// <summary>
        /// Processes a symbol from the L-system string to determine the appropriate dungeon
        /// generation action; each symbol represents a specific action, such as creating a
        /// room, adding a corridor, or changing the direction of the turtle
        /// </summary>
        /// <param name="symbol">
        /// A character from the L-system string that defines dungeon generation actions. For example,
        /// 'S' creates a Start room, 'R' creates a Standard room, '+' turns the turtle right,
        /// and '[' initiates a branch by saving the current state.
        /// </param>
        private void ProcessSymbol(char symbol)
        {
            switch (symbol)
            {
                // Start room
                case 'S':
                    CreateRoom(RoomType.Start);
                    break;
                
                // Standard room
                case 'R':
                    CreateRoom(RoomType.Standard);
                    break;
                
                // Boss room
                case 'B':
                    CreateRoom(RoomType.Boss);
                    break;
                
                // Treasure room
                case 'T':
                    CreateRoom(RoomType.Treasure);
                    break;
                
                // Safe room
                case 'F':
                    CreateRoom(RoomType.Safe);
                    break;
                
                // Corridor
                case 'C':
                    CreateCorridor();
                    break;
                
                // Start branch
                case '[':
                    _stateStack.Push(_currentState.Clone());
                    break;
                
                // End branch
                case ']':
                    if (_stateStack.Count > 0)
                    {
                        _currentState = _stateStack.Pop();
                    }
                    break;
                
                // Turn right
                case '+':
                    TurnRight();
                    break;
                
                // Turn left
                case '-':
                    TurnLeft();
                    break;
                
                // Stairs up
                case '^':
                    MoveUpOneFloor(_currentState.Position);
                    break;
                
                case 'v':
                    MoveDownOneFloor(_currentState.Position);
                    break;
            }
        }

        /// <summary>
        /// Creates a room with specific properties based on the specified room type;
        /// the size and position of the room are determined according to the dungeon
        /// configuration and constraints; we adjust the room dimensions for
        /// special room types and add the room's data to the dungeon layout,
        /// including marking its occupied cells, defining its door positions,
        /// and repositioning the turtle to the exit point of the newly created room
        /// </summary>
        /// <param name="type">
        /// The type of the room to create; determines the size and properties
        /// of the room, such as being a Boss room, Treasure room, or Standard room.
        /// </param>
        private void CreateRoom(RoomType type)
        {
            Vector2Int size = _grammar.GetRandomRoomSize();

            // Adjust size based on room type
            switch (type)
            {
                // Special rooms should be larger
                case RoomType.Boss:
                    size = new Vector2Int(
                        Mathf.Max(size.x, _config.MaxRoomSize.x - 1),
                        Mathf.Max(size.y, _config.MaxRoomSize.y - 1)
                    );
                    break;
                
                case RoomType.Treasure:
                case RoomType.Safe:
                    size = new Vector2Int(
                        Mathf.Max(size.x, (_config.MinRoomSize.x + _config.MaxRoomSize.x) / 2),
                        Mathf.Max(size.y, (_config.MinRoomSize.y + _config.MaxRoomSize.y) / 2)
                    );
                    break;
            }

            Vector2Int roomPosition = FindValidRoomPosition(size);

            // Exit case - this room is not valid
            if (roomPosition == Vector2Int.one * -1000)
            {
                Debug.LogWarning($"Failed to place {type} room of size {size} at " +
                                 $"{_currentState.Position} facing {_currentState.Facing}"
                );
                return;
            }
            
            // Create room data
            RoomData room = new RoomData(_roomIDCounter++, type, roomPosition, size, _currentFloor);
            Rooms.Add(room);
            
            // Mark cells as occupied
            foreach (Vector2Int cellPosition in room.OccupiedCells)
            {
                DungeonCell cell = GetOrCreateCell(cellPosition);
                cell.Type = CellType.Room;
                cell.IsOccupied = true;
                cell.RoomID = room.RoomID;
                cell.FloorLevel = room.FloorLevel;
            }
            
            // Move turtle to the exit point of the room
            Vector2Int exitPoint = GetRoomExitPoint(room);
            _currentState.Position = exitPoint;
        }

        /// <summary>
        /// Creates a corridor of random length starting from the current position of the turtle,
        /// extending in the direction the turtle is currently facing; the corridor is built one
        /// segment at a time until reaching the maximum allowed length, encountering a room, or
        /// exceeding the boundaries of the grid
        /// </summary>
        private void CreateCorridor()
        {
            int length = _grammar.GetRandomCorridorLength();

            for (int step = 0; step < length; step++)
            {
                //  Weâ€™re already adjacent to a room from the current cell, enter now
                if (TryFindAdjacentRoom(_currentState.Position, 
                        out Vector2Int roomCellNow, 
                        out Direction faceNow, 
                        out RoomData roomNow)
                )
                {
                    // If that wall has no door yet, place a door here; if it already has one, keep walking
                    if (!RoomAlreadyHasDoorOnWall(roomNow, faceNow))
                    {
                        // Current cell must be corridor (outside)
                        DungeonCell current = GetOrCreateCell(_currentState.Position);
                        if (current.Type == CellType.Empty)
                        {
                            current.Type = CellType.Corridor; 
                            current.IsOccupied = true; 
                            current.FloorLevel = _currentFloor;
                        }

                        // Record the door and stop (corridor ends at the door)
                        roomNow.DoorPositions.Add(_currentState.Position);
                        roomNow.DoorDirections.Add(faceNow);
                        break;
                    }
                }

                // Candidate step forward
                Vector2Int nextPos = MoveForward(_currentState.Position, _currentState.Facing);
                
                // Exit case - the next position is not in bounds
                if (!IsInBounds(nextPos)) break;

                DungeonCell forward = GetCell(nextPos);

                // If going straight into a room, place a door ahead and stop
                if (forward is { Type: CellType.Room })
                {
                    // Ensure current outside is corridor
                    DungeonCell current = GetOrCreateCell(_currentState.Position);
                    if (current.Type == CellType.Empty)
                    {
                        current.Type = CellType.Corridor; 
                        current.IsOccupied = true; 
                        current.FloorLevel = _currentFloor;
                    }

                    RoomData target = Rooms.Find(r => r.RoomID == forward.RoomID);
                    if (target != null)
                    {
                        target.DoorPositions.Add(_currentState.Position);
                        target.DoorDirections.Add(_currentState.Facing);
                    }
                    break;
                }

                // Step into the next cell of the corridor
                DungeonCell next = GetOrCreateCell(nextPos);
                if (next.Type == CellType.Empty)
                {
                    next.Type = CellType.Corridor; 
                    next.IsOccupied = true; 
                    next.FloorLevel = _currentFloor;
                }
                
                // Update the current state
                _currentState.Position = nextPos;

                // Skip If the new cell is not hugging a room
                if (!TryFindAdjacentRoom(nextPos,
                        out Vector2Int roomCellNext,
                        out Direction faceNext,
                        out RoomData roomNext)) continue;
                
                // Skip if this wall already has a door
                if (RoomAlreadyHasDoorOnWall(roomNext, faceNext)) continue;
                    
                // Add a door position by entering the room
                roomNext.DoorPositions.Add(nextPos);
                roomNext.DoorDirections.Add(faceNext);
                break;
            }
        }

        /// <summary>
        /// Finds a valid position on the grid to place a room of the specified size
        /// based on the current state and dungeon constraints
        /// </summary>
        /// <param name="size">The dimensions of the room to be placed</param>
        /// <returns>
        /// A valid position as a Vector2Int if the room can be placed without
        /// overlapping or exceeding the grid bounds; otherwise, returns a
        /// marker Vector2Int.one * -1000 to indicate an invalid position
        /// </returns>
        private Vector2Int FindValidRoomPosition(Vector2Int size)
        {
            // Try the current position first
            Vector2Int testPosition = _currentState.Position;

            // Exit case - this position is valid
            if (CanPlaceRoom(testPosition, size)) return testPosition;

            for (int distance = 1; distance <= 10; distance++)
            {
                // Try moving forward in the current direction
                testPosition = _currentState.Position;
                for (int i = 0; i < distance; i++)
                {
                    testPosition = MoveForward(testPosition, _currentState.Facing);
                }

                // Exit case - this position is valid
                if (CanPlaceRoom(testPosition, size)) return testPosition;
            }

            // Invalid position marker
            return Vector2Int.one * -1000;
        }

        /// <summary>
        /// Determines whether a room can be placed at a specified position with a given size on the dungeon grid
        /// </summary>
        /// <param name="position">The starting position on the grid where the room is to be placed</param>
        /// <param name="size">The dimensions of the room to be placed</param>
        /// <returns>
        /// True if the room can be placed at the specified position without
        /// overlapping other rooms or exceeding grid bounds; otherwise false
        /// </returns>
        private bool CanPlaceRoom(Vector2Int position, Vector2Int size)
        {
            // Exit case - the room does not fit within grid bounds
            if (position.x < 0 || position.y < 0 ||
                position.x + size.x >= _config.MaxGridSize.x ||
                position.y + size.y >= _config.MaxGridSize.y)
            {
                Debug.Log($"Room at {position} with size {size} does not fit within grid bounds");
                return false;
            }
            
            // Check if any cell is already occupied by a room
            // If buffer ON: check ring around the footprint; if OFF: only check the interior
            for (int dx = -(_config.OneCellBuffer ? 1 : 0); dx < size.x + (_config.OneCellBuffer ? 1 : 0); dx++)
            {
                for (int dz = -(_config.OneCellBuffer ? 1 : 0); dz < size.y + (_config.OneCellBuffer ? 1 : 0); dz++)
                {
                    Vector2Int targetPosition = position + new Vector2Int(dx, dz);
                    DungeonCell cell = GetCell(targetPosition);
                    bool inside = dx >= 0 && dx < size.x && dz >= 0 && dz < size.y;

                    if (_config.OneCellBuffer)
                    {
                        if (cell is { IsOccupied: true }) return false;
                    }
                    else
                    {
                        if (inside && cell is { IsOccupied: true }) return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Determines the exit point of a room based on the current facing direction of the turtle
        /// </summary>
        /// <param name="room">The room for which the exit point is being calculated</param>
        /// <returns>The grid position of the room's exit point</returns>
        private Vector2Int GetRoomExitPoint(RoomData room)
        {
            // Get the edge position based on the turtle's facing direction
            Vector2Int center = room.GetCenter();

            switch (_currentState.Facing)
            {
                case Direction.North:
                    return new Vector2Int(center.x, room.GridPosition.y + room.Size.y);
                
                case Direction.South:
                    return new Vector2Int(center.x, room.GridPosition.y - 1);
                
                case Direction.East:
                    return new Vector2Int(room.GridPosition.x + room.Size.x, center.y);
                
                case Direction.West:
                    return new Vector2Int(room.GridPosition.x - 1, center.y);
                
                default:
                    return center;
            }
        }

        /// <summary>
        /// Updates the turtle's current facing direction by rotating 90 degrees clockwise
        /// </summary>
        private void TurnRight()
        {
            _currentState.Facing = _currentState.Facing switch
            {
                Direction.North => Direction.East,
                Direction.East => Direction.South,
                Direction.South => Direction.West,
                Direction.West => Direction.North,
                _ => _currentState.Facing
            };
        }

        /// <summary>
        /// Updates the turtle's current facing direction by rotating 90 degrees counterclockwise
        /// </summary>
        private void TurnLeft()
        {
            _currentState.Facing = _currentState.Facing switch
            {
                Direction.North => Direction.West,
                Direction.West => Direction.South,
                Direction.South => Direction.East,
                Direction.East => Direction.North,
                _ => _currentState.Facing
            };
        }

        /// <summary>
        /// Moves the dungeon generation context up by one floor, creating a staircase at the current position
        /// and preparing the corresponding landing cell on the new floor
        /// </summary>
        /// <param name="position">
        /// The current position of the turtle within the dungeon grid, which is used as the base for the staircase
        /// and the landing on the next floor
        /// </param>
        private void MoveUpOneFloor(Vector2Int position)
        {
            // Exit case - we are already on the top floor
            if (_currentFloor >= _config.Floors - 1) return;
            
            // Mark base as stairs
            DungeonCell baseCell = GetOrCreateCell(position);
            baseCell.Type = CellType.Stairs;
            baseCell.IsOccupied = true;
            baseCell.FloorLevel = _currentFloor;
            
            // Go up a floor
            _currentFloor += 1;
            _currentState.FloorLevel = _currentFloor;
            
            // Ensure landing cell exists on the new floor
            DungeonCell landingCell = GetOrCreateCell(position);
            landingCell.Type = CellType.StairLanding;
            landingCell.IsOccupied = false;
            landingCell.FloorLevel = _currentFloor;
        }

        /// <summary>
        /// Moves the dungeon turtle down one floor, updating the current floor level and creating
        /// the necessary stair and landing cells at the specified position
        /// </summary>
        /// <param name="position">
        /// The grid position where the stairs and landing cells will be created during the floor transition
        /// </param>
        private void MoveDownOneFloor(Vector2Int position)
        {
            // Exit case - we are already on the bottom floor
            if (_currentFloor <= 0 ) return;
            
            // Mark base as stairs
            DungeonCell baseCell = GetOrCreateCell(position);
            baseCell.Type = CellType.Stairs;
            baseCell.IsOccupied = true;
            baseCell.FloorLevel = _currentFloor;
            
            // Go up a floor
            _currentFloor -= 1;
            _currentState.FloorLevel = _currentFloor;
            
            // Ensure landing cell exists on the new floor
            DungeonCell landingCell = GetOrCreateCell(position);
            landingCell.Type = CellType.StairLanding;
            landingCell.IsOccupied = false;
            landingCell.FloorLevel = _currentFloor;
        }

        private bool TryFindAdjacentRoom(Vector2Int position, out Vector2Int roomCellPosition,
            out Direction facingIntoRoom, out RoomData room)
        {
            // Check left, right, forward, and back neighbor to the current position
            (Vector2Int, Direction)[] checks =
            {
                (Vector2Int.up, Direction.North),
                (Vector2Int.down, Direction.South),
                (Vector2Int.right, Direction.East),
                (Vector2Int.left, Direction.West)
            };

            foreach ((Vector2Int offset, Direction facing) in checks)
            {
                DungeonCell neighbor = GetCell(position + offset);
                if(neighbor is { IsOccupied: true, Type: CellType.Room })
                {
                    roomCellPosition = neighbor.GridPosition;
                    facingIntoRoom = facing;
                    room = Rooms.Find(r => r.RoomID == neighbor.RoomID);
                    return room != null;
                }
            }

            roomCellPosition = default;
            facingIntoRoom = Direction.North;
            room = null;
            return false;
        }

        /// <summary>
        /// Calculates the new position by moving forward in the specified direction from the given position
        /// </summary>
        /// <param name="position">The current grid position of the turtle</param>
        /// <param name="direction">The direction in which the turtle is moving</param>
        /// <returns>The new grid position after moving forward in the specified direction</returns>
        private Vector2Int MoveForward(Vector2Int position, Direction direction)
        {
            return direction switch
            {
                Direction.North => position + Vector2Int.up,
                Direction.South => position + Vector2Int.down,
                Direction.East => position + Vector2Int.right,
                Direction.West => position + Vector2Int.left,
                _ => position
            };
        }

        /// <summary>
        /// Determines whether the specified position is within the bounds of the dungeon grid
        /// </summary>
        /// <param name="position">The grid position to check</param>
        /// <returns>True if the position is within the bounds; otherwise, false</returns>
        private bool IsInBounds(Vector2Int position)
        {
            return position.x >= 0 && position.x < _config.MaxGridSize.x &&
                   position.y >= 0 && position.y < _config.MaxGridSize.y;
        }

        /// <summary>
        /// Retrieves an existing DungeonCell at the specified position or creates a new one if it doesn't exist
        /// </summary>
        /// <param name="position">The grid position of the cell to retrieve or create</param>
        /// <returns>The DungeonCell at the specified position</returns>
        private DungeonCell GetOrCreateCell(Vector2Int position)
        {
            // Add the cell to the grid if it doesn't exist
            if(!Grid.ContainsKey(position))
                Grid.Add(position, new DungeonCell(position, _currentFloor));

            // Return the cell at the given position
            return Grid[position];
        }

        /// <summary>
        /// Retrieves a DungeonCell from the grid based on the specified position
        /// </summary>
        /// <param name="position">The grid position of the cell to retrieve</param>
        /// <returns>The DungeonCell at the specified position, or null if no cell exists</returns>
        private DungeonCell GetCell(Vector2Int position)
        {
            return Grid.GetValueOrDefault(position);
        }

        /// <summary>
        /// Constructs walls for the dungeon by iterating through all cells in the grid
        /// and determining the presence of walls based on the occupancy of neighboring cells
        /// </summary>
        public void BuildWalls()
        {
            // Iterate through each cell in the grid
            foreach (KeyValuePair<Vector2Int, DungeonCell> kvp in Grid)
            {
                DungeonCell cell = kvp.Value;

                // Exit case - the cell is not occupied
                if (!cell.IsOccupied) continue;
                
                // Get the cell position
                Vector2Int position = cell.GridPosition;
                
                SetWall(Direction.North, position, cell);
                SetWall(Direction.South, position, cell);
                SetWall(Direction.East, position, cell);
                SetWall(Direction.West, position, cell);
            }
        }

        private void SetWall(Direction direction, Vector2Int position, DungeonCell cell)
        {
            Vector2Int vectorDirection = direction switch
            {
                Direction.North => Vector2Int.up,
                Direction.South => Vector2Int.down,
                Direction.East => Vector2Int.right,
                Direction.West => Vector2Int.left,
                _ => Vector2Int.zero
            };
            
            Vector2Int neighborPosition = position + vectorDirection;
            DungeonCell neighbor = GetCell(neighborPosition);

            // If no neighbor (empty/out of bounds): put a wall
            bool neighborOccupied = neighbor is { IsOccupied: true };
            if (!neighborOccupied)
            {
                ApplyWall(cell, direction, true);
                return;
            }
            
            // Interior of the same room: no wall
            bool bothRooms = cell.Type == CellType.Room && neighbor.Type == CellType.Room;
            if (bothRooms && cell.RoomID == neighbor.RoomID)
            {
                ApplyWall(cell, direction, false);
                return;
            }

            if (bothRooms && cell.RoomID != neighbor.RoomID)
            {
                bool hasDoor = HasDoorBetween(position, neighborPosition);

                // Only have one doorway per shared wall as a stable "leader"
                bool isLeadingDoor = position.x < neighborPosition.x ||
                               (position.x == neighborPosition.x && position.y < neighborPosition.y);

                // Check if a door is not already recorded for this edge
                if (!hasDoor && isLeadingDoor)
                {
                    // Find the room data for the neighbor room
                    RoomData room = Rooms.Find(r => r.RoomID == neighbor.RoomID);
                    
                    // Get the direction from this room to the neighboring room
                    Direction face = direction;

                    // Check if the neighboring room exists
                    if (room != null && !RoomAlreadyHasDoorOnWall(room, face))
                    {
                        // Get the direction from the current room 'outside'
                        // toward the neighboring room 'inside'
                        room.DoorPositions.Add(position);
                        room.DoorDirections.Add(face);
                        hasDoor = true;
                    }
                }
                
                // With a door recorded, keep the edge open
                ApplyWall(cell, direction, !hasDoor);
            }
            
            
            // If two corridors are next to each other, don't have any walls between them
            bool corridorEdge = cell.Type == CellType.Corridor && neighbor.Type == CellType.Corridor;
            if (corridorEdge)
            {
                ApplyWall(cell, direction, false);
                return;
            }
            
            // Room edge: one side is a room, or two different rooms
            bool isRoomEdge = cell.Type == CellType.Room || neighbor.Type == CellType.Room;
            if (isRoomEdge)
            {
                // Keep a wall unless a door is recorded
                bool hasDoor = HasDoorBetween(position, neighborPosition);
                ApplyWall(cell, direction, !hasDoor);
                return;
            }

            ApplyWall(cell, direction, false);
        }

        private void ApplyWall(DungeonCell cell, Direction direction, bool on)
        {
            switch (direction)
            {
                case Direction.North:
                    cell.HasWallNorth = on;
                    break;
                case Direction.South:
                    cell.HasWallSouth = on;
                    break;
                case Direction.East:
                    cell.HasWallEast = on;
                    break;
                case Direction.West:
                    cell.HasWallWest = on;
                    break;
            }
        }

        private bool HasDoorBetween(Vector2Int a, Vector2Int b)
        {
            // Get the direction from the corridor 'outside' toward the room' inside'
            Vector2Int direction = new Vector2Int(
                Mathf.Clamp(b.x - a.x, -1, 1),
                Mathf.Clamp(b.y - a.y, -1, 1)
            );

            // Get the facing direction of the door
            Direction facing = Direction.North;
            if (direction == Vector2Int.up) facing = Direction.North;
            if (direction == Vector2Int.down) facing = Direction.South;
            if (direction == Vector2Int.right) facing = Direction.East;
            if (direction == Vector2Int.left) facing = Direction.West;

            // Iterate through each room
            foreach (RoomData room in Rooms)
            {
                // Iterate through each door position
                for (int i = 0; i < room.DoorPositions.Count; i++)
                {
                    // Exit case - if there is a door at the current position with the same facing orientation
                    if (room.DoorPositions[i] == a && room.DoorDirections[i] == facing) return true;
                    
                    // Exit case - Reverse check (in case from iterating from inside to outside)
                    if(room.DoorPositions[i] == b && room.DoorDirections[i] == Opposite(facing)) return true;
                }
            }

            return false;
        }

        private bool RoomAlreadyHasDoorOnWall(RoomData room, Direction wallSide)
        {
            for (int i = 0; i < room.DoorPositions.Count; i++)
            {
                if (room.DoorDirections[i] == wallSide) return true;
            }

            return false;
        }

        private Direction Opposite(Direction direction)
        {
            return direction switch
            {
                Direction.North => Direction.South,
                Direction.South => Direction.North,
                Direction.East => Direction.West,
                Direction.West => Direction.East,
                _ => direction
            };
        }
    }
}