using System.Collections.Generic;
using UnityEngine;

namespace Didionysymus.DungeonGeneration.LSystem
{
    /// <summary>
    /// A turtle that walks through the L-system string
    /// and creates spatial dungeon data
    /// </summary>
    public class DungeonTurtle
    {
        private class TurtleState
        {
            public Vector2Int Position;
            public Direction Facing;

            public TurtleState(Vector2Int position, Direction facing)
            {
                Position = position;
                Facing = facing;
            }
            
            public TurtleState Clone() => new TurtleState(Position, Facing);
        }

        private TurtleState _currentState;
        private readonly Stack<TurtleState> _stateStack;
        private readonly DungeonConfig _config;
        private readonly LSystemGrammar _grammar;

        private int _roomIDCounter = 0;
        
        public Dictionary<Vector2Int, DungeonCell> Grid { get; private set; }
        public List<RoomData> Rooms { get; private set; }

        public DungeonTurtle(DungeonConfig config, LSystemGrammar grammar)
        {
            // Set parameters
            _config = config;
            _grammar = grammar;
            
            // Initialize data structures
            _stateStack = new Stack<TurtleState>();
            Grid = new Dictionary<Vector2Int, DungeonCell>();
            Rooms = new List<RoomData>();

            // Start at the center of the grid, facing north
            Vector2Int startPosition = _config.MaxGridSize / 2;
            _currentState = new TurtleState(startPosition, Direction.North);
        }

        /// <summary>
        /// Interprets an L-system string and processes each symbol to construct the dungeon layout
        /// by following predefined dungeon generation rules
        /// </summary>
        /// <param name="lSystemString">
        /// The string generated by the L-system that encodes the sequence of actions for the turtle
        /// to perform, such as moving, turning, or creating dungeon structures
        /// </param>
        public void Walkthrough(string lSystemString)
        {
            // Process each symbol in the string
            foreach (char symbol in lSystemString)
            {
                ProcessSymbol(symbol);
            }

            // Ensure all rooms are connected
            EnsureConnectivity();
            
            // After interpretation, build walls
            CreateDoors();
            BuildWalls();
        }

        /// <summary>
        /// Processes a symbol from the L-system string to determine the appropriate dungeon
        /// generation action; each symbol represents a specific action, such as creating a
        /// room, adding a corridor, or changing the direction of the turtle
        /// </summary>
        /// <param name="symbol">
        /// A character from the L-system string that defines dungeon generation actions. For example,
        /// 'S' creates a Start room, 'R' creates a Standard room, '+' turns the turtle right,
        /// and '[' initiates a branch by saving the current state.
        /// </param>
        private void ProcessSymbol(char symbol)
        {
            switch (symbol)
            {
                // Start room
                case 'X':
                    CreateRoom(RoomType.Start);
                    break;
                
                // Standard room
                case 'R':
                    CreateRoom(RoomType.Standard);
                    break;
                
                // Boss room
                case 'B':
                    CreateRoom(RoomType.Boss);
                    break;
                
                // Treasure room
                case 'T':
                    CreateRoom(RoomType.Treasure);
                    break;
                
                // Safe room
                case 'F':
                    CreateRoom(RoomType.Safe);
                    break;
                
                // Corridor
                case 'C':
                    CreateCorridor();
                    break;
                
                // Start branch
                case '[':
                    _stateStack.Push(_currentState.Clone());
                    break;
                
                // End branch
                case ']':
                    if (_stateStack.Count > 0)
                    {
                        _currentState = _stateStack.Pop();
                    }
                    break;
                
                // Turn right
                case '+':
                    TurnRight();
                    break;
                
                // Turn left
                case '-':
                    TurnLeft();
                    break;
            }
        }

        /// <summary>
        /// Creates a room with specific properties based on the specified room type;
        /// the size and position of the room are determined according to the dungeon
        /// configuration and constraints; we adjust the room dimensions for
        /// special room types and add the room's data to the dungeon layout,
        /// including marking its occupied cells, defining its door positions,
        /// and repositioning the turtle to the exit point of the newly created room
        /// </summary>
        /// <param name="type">
        /// The type of the room to create; determines the size and properties
        /// of the room, such as being a Boss room, Treasure room, or Standard room.
        /// </param>
        private void CreateRoom(RoomType type)
        {
            Vector2Int size = _grammar.GetRandomRoomSize();

            // Adjust size based on room type
            switch (type)
            {
                // Special rooms should be larger
                case RoomType.Boss:
                    size = new Vector2Int(
                        Mathf.Max(size.x, _config.MaxRoomSize.x - 1),
                        Mathf.Max(size.y, _config.MaxRoomSize.y - 1)
                    );
                    break;
                
                case RoomType.Treasure:
                case RoomType.Safe:
                    size = new Vector2Int(
                        Mathf.Max(size.x, (_config.MinRoomSize.x + _config.MaxRoomSize.x) / 2),
                        Mathf.Max(size.y, (_config.MinRoomSize.y + _config.MaxRoomSize.y) / 2)
                    );
                    break;
            }

            Vector2Int roomPosition = FindValidRoomPosition(size);

            // Exit case - this room is not valid
            if (roomPosition == Vector2Int.one * -1000)
            {
                Debug.LogWarning($"Failed to place {type} room of size {size} at " +
                                 $"{_currentState.Position} facing {_currentState.Facing}"
                );
                return;
            }
            
            // Create room data
            RoomData room = new RoomData(_roomIDCounter++, type, roomPosition, size);
            Rooms.Add(room);
            
            // Mark cells as occupied
            foreach (Vector2Int cellPosition in room.OccupiedCells)
            {
                DungeonCell cell = GetOrCreateCell(cellPosition);
                cell.Type = CellType.Room;
                cell.IsOccupied = true;
                cell.RoomID = room.RoomID;
            }
            
            // Move turtle to the exit point of the room
            Vector2Int exitPoint = GetRoomExitPoint(room);
            _currentState.Position = exitPoint;
        }

        /// <summary>
        /// Creates a corridor of random length starting from the current position of the turtle,
        /// extending in the direction the turtle is currently facing; the corridor is built one
        /// segment at a time until reaching the maximum allowed length, encountering a room, or
        /// exceeding the boundaries of the grid
        /// </summary>
        private void CreateCorridor()
        {
            int length = _grammar.GetRandomCorridorLength();
            bool connectedToSomething = false;
    
            for (int step = 0; step < length; step++)
            {
                Vector2Int nextPos = MoveForward(_currentState.Position, _currentState.Facing);
        
                // Check bounds
                if (!IsInBounds(nextPos)) break;
        
                DungeonCell nextCell = GetOrCreateCell(nextPos);
        
                // If we hit a room, we've connected - stop
                if (nextCell.Type == CellType.Room)
                {
                    connectedToSomething = true;
                    break;
                }
        
                // If we hit another corridor, we've connected - continue a bit more then stop
                if (nextCell.Type == CellType.Corridor)
                {
                    connectedToSomething = true;
                    // Continue for 1-2 more steps to ensure good overlap
                    if (step < length - 2)
                    {
                        _currentState.Position = nextPos;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
        
                // Mark as corridor if empty
                if (nextCell.Type == CellType.Empty)
                {
                    nextCell.Type = CellType.Corridor;
                    nextCell.IsOccupied = true;
                }
        
                _currentState.Position = nextPos;
        
                // Check if we're adjacent to anything
                if (IsAdjacentToOccupied(nextPos))
                {
                    connectedToSomething = true;
                }
            }
    
            // If we didn't connect to anything, try to extend toward nearest occupied cell
            if (!connectedToSomething)
            {
                ExtendCorridorToConnect();
            }
        }

        /// <summary>
        /// Checks if the given position is adjacent to any occupied cell in the dungeon grid
        /// </summary>
        /// <param name="position">
        /// The grid position to check for adjacent occupied cells
        /// </param>
        /// <returns>
        /// Returns true if any of the adjacent cells are occupied; otherwise, false
        /// </returns>
        private bool IsAdjacentToOccupied(Vector2Int position)
        {
            // Get the neighboring positions
            Vector2Int[] neighbors =
            {
                position + Vector2Int.up,
                position + Vector2Int.down,
                position + Vector2Int.left,
                position + Vector2Int.right
            };
            
            // Iterate through each neighbor
            foreach (Vector2Int neighbor in neighbors)
            {
                // If the neighbor has a cell and the cell is occupied, return true
                if (Grid.TryGetValue(neighbor, out DungeonCell cell) && cell.IsOccupied)
                {
                    return true;
                }
            }
            
            return false;
        }

        /// <summary>
        /// Extends a corridor to connect with the nearest occupied cell within a specified range
        /// by creating a linear path through unoccupied cells; the extension first moves horizontally,
        /// then vertically until it reaches the target or the bounds of the dungeon grid.
        /// </summary>
        private void ExtendCorridorToConnect()
        {
            // Get the current position and the nearest occupied position
            Vector2Int currentPos = _currentState.Position;
            Vector2Int? nearestOccupied = FindNearestOccupiedCell(currentPos, 10);
            
            // Exit case - there is not an occupied cell within the specified range
            if (!nearestOccupied.HasValue) return;
            
            // Create a simple path toward the nearest occupied cell
            Vector2Int target = nearestOccupied.Value;
            
            // Move horizontally first
            while (currentPos.x != target.x && IsInBounds(currentPos))
            {
                currentPos.x += target.x > currentPos.x 
                    ? 1 
                    : -1;
                    
                // Get the cell at the current position
                DungeonCell cell = GetOrCreateCell(currentPos);
                
                // Set it as a corridor if it's empty
                if (cell.Type == CellType.Empty)
                {
                    cell.Type = CellType.Corridor;
                    cell.IsOccupied = true;
                }
                else if (cell.IsOccupied)
                {
                    // If the cell is occupied, we've connected, so break out of the loop
                    break;
                }
            }
                
            // Move vertically
            while (currentPos.y != target.y && IsInBounds(currentPos))
            {
                currentPos.y += target.y > currentPos.y 
                    ? 1 
                    : -1;
                    
                // Get the cell at the current position
                DungeonCell cell = GetOrCreateCell(currentPos);
                
                // Set it as a corridor if it's empty
                if (cell.Type == CellType.Empty)
                {
                    cell.Type = CellType.Corridor;
                    cell.IsOccupied = true;
                }
                else if (cell.IsOccupied)
                {
                    // If the cell is occupied, we've connected, so break out of the loop'
                    break;
                }
            }
                
            _currentState.Position = currentPos;
        }

        /// <summary>
        /// Searches for the nearest occupied cell within a specified range from the given starting position
        /// </summary>
        /// <param name="from">
        /// The starting position from which the search for the nearest occupied cell begins
        /// </param>
        /// <param name="maxDistance">
        /// The maximum search radius in cells; the search will not extend beyond this distance
        /// </param>
        /// <returns>
        /// The position of the nearest occupied cell as a Vector2Int, or null if no occupied cell is found within the specified range
        /// </returns>
        private Vector2Int? FindNearestOccupiedCell(Vector2Int from, int maxDistance)
        {
            for (int radius = 1; radius <= maxDistance; radius++)
            {
                for (int dx = -radius; dx <= radius; dx++)
                {
                    for (int dy = -radius; dy <= radius; dy++)
                    {
                        if (Mathf.Abs(dx) != radius && Mathf.Abs(dy) != radius) continue;
                        
                        Vector2Int checkPos = from + new Vector2Int(dx, dy);
                        if (Grid.TryGetValue(checkPos, out DungeonCell cell) && cell.IsOccupied)
                        {
                            return checkPos;
                        }
                    }
                }
            }
            
            return null;
        }

        /// <summary>
        /// Ensures that all rooms in the dungeon are part of a single connected component by identifying disconnected
        /// groups of rooms and creating connections between them as necessary.
        /// </summary>
        private void EnsureConnectivity()
        {
            // Exit case - there are no extra rooms to connect
            if (Rooms.Count <= 1) return;
            
            // Find all connected components
            HashSet<int> visitedRooms = new HashSet<int>();
            List<List<int>> components = new List<List<int>>();
            
            // Iterate through each room
            foreach (RoomData room in Rooms)
            {
                // Skip if we've already visited this room
                if (visitedRooms.Contains(room.RoomID)) continue;
                
                // Flood fill the room to identify all rooms it belongs to
                List<int> component = new List<int>();
                FloodFillRooms(room.RoomID, visitedRooms, component);
                components.Add(component);
            }
            
            // If we have multiple components, connect them
            if (components.Count > 1)
            {
                // Connect each component to the first (main) component
                for (int i = 1; i < components.Count; i++)
                {
                    ConnectComponents(components[0], components[i]);
                }
            }
        }

        /// <summary>
        /// Performs a flood fill operation starting from a given room, traversing through connected corridors
        /// and adjacent rooms to identify all rooms belonging to the same connected component
        /// </summary>
        /// <param name="roomID">
        /// The ID of the room from which the flood fill operation begins
        /// </param>
        /// <param name="visited">
        /// A set of room IDs that have already been visited to prevent redundant processing during the flood fill
        /// </param>
        /// <param name="component">
        /// A list that collects the IDs of all rooms that are part of the same connected component
        /// </param>
        private void FloodFillRooms(int roomID, HashSet<int> visited, List<int> component)
        {
            // Exit case - we've already visited this room'
            if (!visited.Add(roomID)) return;

            component.Add(roomID);
            
            RoomData room = Rooms.Find(r => r.RoomID == roomID);
            if (room == null) return;
            
            // Check all cells adjacent to this room
            foreach (Vector2Int cellPos in room.OccupiedCells)
            {
                Vector2Int[] neighbors = {
                    cellPos + Vector2Int.up,
                    cellPos + Vector2Int.down,
                    cellPos + Vector2Int.left,
                    cellPos + Vector2Int.right
                };
                
                foreach (Vector2Int neighbor in neighbors)
                {
                    // Skip if unable to retrieve a cell from the neighbor position
                    if (!Grid.TryGetValue(neighbor, out DungeonCell neighborCell)) continue;
                    
                    // If it's a corridor, trace where it leads
                    if (neighborCell.Type == CellType.Corridor)
                    {
                        HashSet<int> reachableRooms = TraceCorridorToRooms(neighbor);
                        foreach (int reachableRoom in reachableRooms)
                        {
                            FloodFillRooms(reachableRoom, visited, component);
                        }
                    }
                    // If it's another room, add it
                    else if (neighborCell.Type == CellType.Room && neighborCell.RoomID != roomID)
                    {
                        FloodFillRooms(neighborCell.RoomID, visited, component);
                    }
                }
            }
        }

        /// <summary>
        /// Traces a corridor starting from the given position to identify all unique room IDs that the corridor connects to
        /// </summary>
        /// <param name="startPos">
        /// The starting position in the grid where the corridor tracing begins
        /// </param>
        /// <returns>
        /// A set of unique room IDs reachable through the corridor traced from the starting position
        /// </returns>
        private HashSet<int> TraceCorridorToRooms(Vector2Int startPos)
        {
            HashSet<int> reachableRooms = new HashSet<int>();
            HashSet<Vector2Int> visitedCells = new HashSet<Vector2Int>();
            Queue<Vector2Int> toVisit = new Queue<Vector2Int>();
            
            toVisit.Enqueue(startPos);
            
            // Trace the corridor to find all rooms it leads to
            while (toVisit.Count > 0)
            {
                Vector2Int current = toVisit.Dequeue();
                
                // Skip if we've already visited this cell
                if (!visitedCells.Add(current)) continue;

                // Skip if unable to retrieve a dungeon cell from this position
                if (!Grid.TryGetValue(current, out DungeonCell cell)) continue;
                
                switch (cell.Type)
                {
                    // If the cell is a room, add it to the list of reachable rooms
                    case CellType.Room:
                        reachableRooms.Add(cell.RoomID);
                        break;
                    
                    // If it's a corridor, continue tracing it
                    case CellType.Corridor:
                    {
                        // Continue tracing through corridors
                        Vector2Int[] neighbors = {
                            current + Vector2Int.up,
                            current + Vector2Int.down,
                            current + Vector2Int.left,
                            current + Vector2Int.right
                        };
                    
                        foreach (Vector2Int neighbor in neighbors)
                        {
                            if (!visitedCells.Contains(neighbor))
                            {
                                toVisit.Enqueue(neighbor);
                            }
                        }

                        break;
                    }
                }
            }
            
            return reachableRooms;
        }

        /// <summary>
        /// Connects two separate dungeon room components by creating a corridor between the closest rooms
        /// from each component
        /// </summary>
        /// <param name="component1">
        /// A list of room IDs representing the first connected component of rooms
        /// </param>
        /// <param name="component2">
        /// A list of room IDs representing the second connected component of rooms
        /// </param>
        private void ConnectComponents(List<int> component1, List<int> component2)
        {
            // Find closest pair of rooms between components
            RoomData room1 = null;
            RoomData room2 = null;
            float minDistance = float.MaxValue;
            
            // Iterate through each room in the first component
            foreach (int id1 in component1)
            {
                // Get the room matching the ID
                RoomData r1 = Rooms.Find(r => r.RoomID == id1);
                
                // Skip if the room is not found
                if (r1 == null) continue;
                
                // Iterate through each room in the second component
                foreach (int id2 in component2)
                {
                    // Get the room matching the ID
                    RoomData r2 = Rooms.Find(r => r.RoomID == id2);
                    
                    // Skip if the room is not found
                    if (r2 == null) continue;
                    
                    // Get the distance between the two rooms
                    float dist = Vector2Int.Distance(r1.GetCenter(), r2.GetCenter());
                    
                    // If the distance is less than the current minimum, update the closest rooms
                    if (dist < minDistance)
                    {
                        minDistance = dist;
                        room1 = r1;
                        room2 = r2;
                    }
                }
            }
            
            // Exit case - no closest rooms found
            if (room1 == null && room2 == null) return;
            
            // Create a corridor between them
            CreateDirectCorridor(room1.GetCenter(), room2.GetCenter());
        }

        /// <summary>
        /// Creates a direct L-shaped corridor between two specified points in the dungeon grid
        /// </summary>
        /// <param name="from">
        /// The starting point of the corridor in grid coordinates
        /// </param>
        /// <param name="to">
        /// The ending point of the corridor in grid coordinates
        /// </param>
        private void CreateDirectCorridor(Vector2Int from, Vector2Int to)
        {
            // Get the current position
            Vector2Int current = from;
            
            // Create L-shaped corridor, first by moving horizontally
            while (current.x != to.x)
            {
                current.x += to.x > current.x 
                    ? 1 : -1;
                
                // Get the cell at the current position
                DungeonCell cell = GetOrCreateCell(current);
                
                // Skip if the cell is not empty
                if (cell.Type != CellType.Empty) continue;
                
                // Set it as a corridor if it's empty'
                cell.Type = CellType.Corridor;
                cell.IsOccupied = true;
            }
            
            // Move vertically
            while (current.y != to.y)
            {
                current.y += to.y > current.y
                    ? 1 
                    : -1;
                
                // Get the cell at the current position
                DungeonCell cell = GetOrCreateCell(current);
                
                // Skip if the cell is not empty
                if (cell.Type != CellType.Empty) continue;
                
                // Set it as a corridor if it's empty
                cell.Type = CellType.Corridor;
                cell.IsOccupied = true;
            }
        }

        /// <summary>
        /// Finds a valid position on the grid to place a room of the specified size
        /// based on the current state and dungeon constraints
        /// </summary>
        /// <param name="size">The dimensions of the room to be placed</param>
        /// <returns>
        /// A valid position as a Vector2Int if the room can be placed without
        /// overlapping or exceeding the grid bounds; otherwise, returns a
        /// marker Vector2Int.one * -1000 to indicate an invalid position
        /// </returns>
        private Vector2Int FindValidRoomPosition(Vector2Int size)
        {
            // Try the current position first
            Vector2Int centerOffset = new Vector2Int(size.x / 2, size.y / 2);
            Vector2Int testPosition = _currentState.Position - centerOffset;

            // Exit case - this position is valid
            if (CanPlaceRoom(testPosition, size)) return testPosition;

            for (int radius = 1; radius <= 15; radius++)
            {
                // Try positions in a square ring around the current position
                for (int dx = -radius; dx <= radius; dx++)
                {
                    for (int dy = -radius; dy <= radius; dy++)
                    {
                        // Only check the perimeter of the square
                        if(Mathf.Abs(dx) != radius && Mathf.Abs(dy) != radius) continue;
                        
                        testPosition = _currentState.Position + new Vector2Int(dx, dy) - centerOffset;

                        if (CanPlaceRoom(testPosition, size)) return testPosition;
                    }
                }
            }

            // If there's still no valid position, try with a smaller room
            if (size.x > _config.MinRoomSize.x || size.y > _config.MinRoomSize.y)
            {
                Vector2Int smallerSize = new Vector2Int(
                    Mathf.Max(_config.MinRoomSize.x, size.x - 1),
                    Mathf.Max(_config.MinRoomSize.y, size.y - 1)
                );
                return FindValidRoomPosition(smallerSize);
            }
            
            // Invalid position marker
            return Vector2Int.one * -1000;
        }

        /// <summary>
        /// Determines whether a room can be placed at a specified position with a given size on the dungeon grid
        /// </summary>
        /// <param name="position">The starting position on the grid where the room is to be placed</param>
        /// <param name="size">The dimensions of the room to be placed</param>
        /// <returns>
        /// True if the room can be placed at the specified position without
        /// overlapping other rooms or exceeding grid bounds; otherwise false
        /// </returns>
        private bool CanPlaceRoom(Vector2Int position, Vector2Int size)
        {
            // Exit case - the room does not fit within grid bounds
            if (position.x < 0 || position.y < 0 ||
                position.x + size.x >= _config.MaxGridSize.x ||
                position.y + size.y >= _config.MaxGridSize.y)
            {
                Debug.Log($"Room at {position} with size {size} does not fit within grid bounds");
                return false;
            }
            
            // Check if any cell is already occupied by a room
            for (int dx = 0; dx < size.x; dx++)
            {
                for (int dz = 0; dz < size.y; dz++)
                {
                    Vector2Int targetPosition = position + new Vector2Int(dx, dz);
                    DungeonCell cell = GetCell(targetPosition);
                    bool inside = dx >= 0 && dx < size.x && dz >= 0 && dz < size.y;

                    if (inside && cell is { IsOccupied: true }) return false;
                }
            }

            return true;
        }

        /// <summary>
        /// Determines the exit point of a room based on the current facing direction of the turtle
        /// </summary>
        /// <param name="room">The room for which the exit point is being calculated</param>
        /// <returns>The grid position of the room's exit point</returns>
        private Vector2Int GetRoomExitPoint(RoomData room)
        {
            // Get the edge position based on the turtle's facing direction
            Vector2Int center = room.GetCenter();

            switch (_currentState.Facing)
            {
                case Direction.North:
                    return new Vector2Int(center.x, room.GridPosition.y + room.Size.y);
                
                case Direction.South:
                    return new Vector2Int(center.x, room.GridPosition.y - 1);
                
                case Direction.East:
                    return new Vector2Int(room.GridPosition.x + room.Size.x, center.y);
                
                case Direction.West:
                    return new Vector2Int(room.GridPosition.x - 1, center.y);
                
                default:
                    return center;
            }
        }

        /// <summary>
        /// Updates the turtle's current facing direction by rotating 90 degrees clockwise
        /// </summary>
        private void TurnRight()
        {
            _currentState.Facing = _currentState.Facing switch
            {
                Direction.North => Direction.East,
                Direction.East => Direction.South,
                Direction.South => Direction.West,
                Direction.West => Direction.North,
                _ => _currentState.Facing
            };
        }

        /// <summary>
        /// Updates the turtle's current facing direction by rotating 90 degrees counterclockwise
        /// </summary>
        private void TurnLeft()
        {
            _currentState.Facing = _currentState.Facing switch
            {
                Direction.North => Direction.West,
                Direction.West => Direction.South,
                Direction.South => Direction.East,
                Direction.East => Direction.North,
                _ => _currentState.Facing
            };
        }

        /// <summary>
        /// Calculates the new position by moving forward in the specified direction from the given position
        /// </summary>
        /// <param name="position">The current grid position of the turtle</param>
        /// <param name="direction">The direction in which the turtle is moving</param>
        /// <returns>The new grid position after moving forward in the specified direction</returns>
        private Vector2Int MoveForward(Vector2Int position, Direction direction)
        {
            return direction switch
            {
                Direction.North => position + Vector2Int.up,
                Direction.South => position + Vector2Int.down,
                Direction.East => position + Vector2Int.right,
                Direction.West => position + Vector2Int.left,
                _ => position
            };
        }

        /// <summary>
        /// Determines whether the specified position is within the bounds of the dungeon grid
        /// </summary>
        /// <param name="position">The grid position to check</param>
        /// <returns>True if the position is within the bounds; otherwise, false</returns>
        private bool IsInBounds(Vector2Int position)
        {
            return position.x >= 0 && position.x < _config.MaxGridSize.x &&
                   position.y >= 0 && position.y < _config.MaxGridSize.y;
        }

        /// <summary>
        /// Retrieves an existing DungeonCell at the specified position or creates a new one if it doesn't exist
        /// </summary>
        /// <param name="position">The grid position of the cell to retrieve or create</param>
        /// <returns>The DungeonCell at the specified position</returns>
        private DungeonCell GetOrCreateCell(Vector2Int position)
        {
            // Add the cell to the grid if it doesn't exist
            if(!Grid.ContainsKey(position))
                Grid.Add(position, new DungeonCell(position));

            // Return the cell at the given position
            return Grid[position];
        }

        /// <summary>
        /// Retrieves a DungeonCell from the grid based on the specified position
        /// </summary>
        /// <param name="position">The grid position of the cell to retrieve</param>
        /// <returns>The DungeonCell at the specified position, or null if no cell exists</returns>
        private DungeonCell GetCell(Vector2Int position)
        {
            return Grid.GetValueOrDefault(position);
        }

        /// <summary>
        /// Constructs walls for the dungeon by iterating through all cells in the grid
        /// and determining the presence of walls based on the occupancy of neighboring cells
        /// </summary>
        public void BuildWalls()
        {
            // Iterate through each cell in the grid
            foreach (KeyValuePair<Vector2Int, DungeonCell> kvp in Grid)
            {
                DungeonCell cell = kvp.Value;

                // Exit case - the cell is not occupied
                if (!cell.IsOccupied) continue;
                
                // Get the cell position
                Vector2Int position = cell.GridPosition;
                
                SetWall(Direction.North, position, cell);
                SetWall(Direction.South, position, cell);
                SetWall(Direction.East, position, cell);
                SetWall(Direction.West, position, cell);
            }
        }

        /// <summary>
        /// Identifies and places doors between rooms and corridors based on adjacent dungeon cells;
        /// updates the door data for each room with positions and directions of the created doors
        /// </summary>
        private void CreateDoors()
        {
            // Clear existing door data
            foreach (RoomData room in Rooms)
            {
                room.DoorPositions.Clear();
                room.DoorDirections.Clear();
            }

            // Iterate through each room
            foreach (RoomData room in Rooms)
            {
                // Get the wall segments of the room in each direction
                Dictionary<Direction, List<Vector2Int>> wallSegments = GetRoomWallSegments(room);

                // Iterate through each wall segment
                foreach (KeyValuePair<Direction, List<Vector2Int>> kvp in wallSegments)
                {
                    Direction wallDirection = kvp.Key;
                    List<Vector2Int> wallCells = kvp.Value;

                    // Skip if there are no wall cells
                    if (wallCells.Count == 0) continue;
                    
                    // Find corridors or other rooms adjacent to this cell
                    List<Vector2Int> validDoorPositions = new List<Vector2Int>();

                    // Iterate through each wall cell
                    foreach (Vector2Int wallCell in wallCells)
                    {
                        // Get the adjacent position to the wall (outside)
                        Vector2Int outsidePosition = GetAdjacentPosition(wallCell, wallDirection);
                        
                        // Skip if there is no cell at the outside position
                        if (!Grid.TryGetValue(outsidePosition, out DungeonCell outsideCell)) continue;

                        // If the cell is occupied and is a corridor or separate room,
                        // add it to the list of valid positions
                        if (outsideCell.IsOccupied && (outsideCell.Type == CellType.Corridor ||
                                                       outsideCell.Type == CellType.Room &&
                                                       outsideCell.RoomID != room.RoomID))
                        {
                            validDoorPositions.Add(wallCell);
                        }
                    }

                    // Place a door between the room and the adjacent cell
                    if (validDoorPositions.Count > 0)
                    {
                        PlaceCenteredDoor(room, wallDirection, validDoorPositions);
                    }
                }
            }
        }

        /// <summary>
        /// Calculates and returns the wall segments of a room organized by direction;
        /// each wall segment consists of a list of grid positions that represent the wall's location in the grid
        /// </summary>
        /// <param name="room">
        /// The room for which the wall segments need to be determined. Contains information about the room's size, position, and other properties
        /// </param>
        /// <returns>
        /// A dictionary where the keys are directions (North, South, East, West) and the values are lists of grid positions
        /// corresponding to the wall segments in that direction
        /// </returns>
        private Dictionary<Direction, List<Vector2Int>> GetRoomWallSegments(RoomData room)
        {
            Dictionary<Direction, List<Vector2Int>> segments = new Dictionary<Direction, List<Vector2Int>>
            {
                { Direction.North, new List<Vector2Int>() },
                { Direction.South, new List<Vector2Int>() },
                { Direction.East, new List<Vector2Int>() },
                { Direction.West, new List<Vector2Int>() }
            };
            
            // North wall
            for (int x = 0; x < room.Size.x; x++)
            {
                segments[Direction.North].Add(room.GridPosition + new Vector2Int(x, room.Size.y - 1));
            }
            
            // South wall
            for (int x = 0; x < room.Size.x; x++)
            {
                segments[Direction.South].Add(room.GridPosition + new Vector2Int(x, 0));
            }
            
            // East wall
            for (int y = 0; y < room.Size.y; y++)
            {
                segments[Direction.East].Add(room.GridPosition + new Vector2Int(room.Size.x - 1, y));
            }
            
            // West wall
            for (int y = 0; y < room.Size.y; y++)
            {
                segments[Direction.West].Add(room.GridPosition + new Vector2Int(0, y));
            }

            return segments;
        }

        /// <summary>
        /// Places a door at the center of the most optimal position on a wall of the given room,
        /// ensuring proper alignment and avoiding corner placements where possible
        /// </summary>
        /// <param name="room">
        /// The room data representing the room the door is being placed in
        /// </param>
        /// <param name="wallDirection">
        /// The direction of the wall on which the door is to be placed
        /// </param>
        /// <param name="validPositions">
        /// A list of valid grid positions, along the specified wall, where a door can potentially be placed
        /// </param>
        private void PlaceCenteredDoor(RoomData room, Direction wallDirection, List<Vector2Int> validPositions)
        {
            // Check if any position on this wall already has a door to any adjacent area
            foreach (Vector2Int pos in validPositions)
            {
                Vector2Int outsidePos = GetAdjacentPosition(pos, wallDirection);
                
                // Exit case - a door exists already to the adjacent position
                if (HasDoorBetween(outsidePos, pos))
                {
                    return;
                }
            }
            
            // Skip corners if possible
            List<Vector2Int> nonCornerPositions = new List<Vector2Int>();
            
            foreach (Vector2Int position in validPositions)
            {
                bool isCorner = IsCornerPosition(room, position);
                if(!isCorner) nonCornerPositions.Add(position);
            }
            
            // Use non-corner positions if available
            List<Vector2Int> positionsToUse = nonCornerPositions.Count > 0 ? nonCornerPositions : validPositions;
            
            // Find continuous segments
            List<List<Vector2Int>> segments = FindContinuousSegments(positionsToUse, wallDirection);
            
            // Place only one door for the entire wall
            if (segments.Count > 0)
            {
                // Find the longest segment
                List<Vector2Int> longestSegment = segments[0];
                foreach (List<Vector2Int> segment in segments)
                {
                    if (segment.Count > longestSegment.Count)
                        longestSegment = segment;
                }
                
                // Place the door in the middle of the segment
                if (longestSegment.Count > 0)
                {
                    // Get the center position of the longest segment
                    int centerIndex = longestSegment.Count / 2;
                    Vector2Int doorPosition = longestSegment[centerIndex];
                    
                    // Add the door (outside position pointing into the room)
                    Vector2Int outsidePos = GetAdjacentPosition(doorPosition, wallDirection);
                    
                    // Double-check one more time before adding
                    if (!HasDoorBetween(outsidePos, doorPosition))
                    {
                        room.DoorPositions.Add(outsidePos);
                        room.DoorDirections.Add(Opposite(wallDirection));
                    }
                }
            }
        }

        /// <summary>
        /// Determines whether a given position within a room is a corner by checking if it lies on
        /// both an X-edge and a Y-edge of the room boundaries
        /// </summary>
        /// <param name="room">
        /// The room data containing information about the room's size and grid position
        /// </param>
        /// <param name="position">
        /// The grid position to be checked, relative to the entire dungeon grid
        /// </param>
        /// <returns>
        /// True if the position is a corner of the room; otherwise, false
        /// </returns>
        private bool IsCornerPosition(RoomData room, Vector2Int position)
        {
            Vector2Int relativePos = position - room.GridPosition;

            bool isXEdge = (relativePos.x == 0 || relativePos.x == room.Size.x - 1);
            bool isYEdge = (relativePos.y == 0 || relativePos.y == room.Size.y - 1);
    
            return isXEdge && isYEdge;
        }

        /// <summary>
        /// Identifies and groups adjacent positions into continuous segments based on their alignment
        /// along a specified wall direction.
        /// </summary>
        /// <param name="positions">
        /// A list of grid positions representing potential door locations along a wall
        /// </param>
        /// <param name="wallDirection">
        /// The direction of the wall (e.g., North, South, East, or West) used to determine alignment
        /// and position sorting
        /// </param>
        /// <returns>
        /// A list of continuous segments, where each segment consists of adjacent positions
        /// aligned along the specified wall direction
        /// </returns>
        private List<List<Vector2Int>> FindContinuousSegments(List<Vector2Int> positions, Direction wallDirection)
        {
            // Exit case - no positions to process
            if (positions.Count == 0) return new List<List<Vector2Int>>();
    
            // Sort positions based on the wall direction
            positions.Sort((a, b) => 
            {
                if (wallDirection == Direction.North || wallDirection == Direction.South)
                    return a.x.CompareTo(b.x);
                
                return a.y.CompareTo(b.y);
            });
    
            // Initialize the current segment
            List<List<Vector2Int>> segments = new List<List<Vector2Int>>();
            List<Vector2Int> currentSegment = new List<Vector2Int> { positions[0] };
    
            // Iterate through the remaining positions
            for (int i = 1; i < positions.Count; i++)
            {
                // Get the distance between the current position and the previous position
                int distance = (wallDirection == Direction.North || wallDirection == Direction.South) 
                    ? Mathf.Abs(positions[i].x - positions[i-1].x)
                    : Mathf.Abs(positions[i].y - positions[i-1].y);
        
                // If the distance is 1, continue the current new segment
                if (distance == 1)
                {
                    currentSegment.Add(positions[i]);
                }
                else
                {
                    // Otherwise, add the current segment to the list of segments
                    // and start a new segment
                    segments.Add(new List<Vector2Int>(currentSegment));
                    currentSegment = new List<Vector2Int> { positions[i] };
                }
            }
    
            segments.Add(currentSegment);
            return segments;
        }

        /// <summary>
        /// Calculates the adjacent position relative to the given position in the specified direction
        /// </summary>
        /// <param name="pos">
        /// The current position represented as a 2D vector
        /// </param>
        /// <param name="direction">
        /// The direction relative to the given position to calculate the adjacent position
        /// </param>
        /// <returns>
        /// A 2D vector representing the adjacent position in the specified direction;
        /// if the direction is undefined, the original position is returned
        /// </returns>
        private Vector2Int GetAdjacentPosition(Vector2Int pos, Direction direction)
        {
            return direction switch
            {
                Direction.North => pos + Vector2Int.up,
                Direction.South => pos + Vector2Int.down,
                Direction.East => pos + Vector2Int.right,
                Direction.West => pos + Vector2Int.left,
                _ => pos
            };
        }

        /// <summary>
        /// Configures the presence or absence of a wall for a specific direction of a dungeon cell
        /// based on its surroundings and the dungeon generation rules
        /// </summary>
        /// <param name="direction">
        /// The cardinal or spatial direction (North, South, East, West) for which the wall is being set
        /// </param>
        /// <param name="position">
        /// The position of the current cell in the grid where the wall is being considered
        /// </param>
        /// <param name="cell">
        /// The dungeon cell object at the specified position for which the wall is being set
        /// </param>
        private void SetWall(Direction direction, Vector2Int position, DungeonCell cell)
        {
            Vector2Int vectorDirection = direction switch
            {
                Direction.North => Vector2Int.up,
                Direction.South => Vector2Int.down,
                Direction.East => Vector2Int.right,
                Direction.West => Vector2Int.left,
                _ => Vector2Int.zero
            };
    
            Vector2Int neighborPosition = position + vectorDirection;
            DungeonCell neighbor = GetCell(neighborPosition);

            // If no neighbor (empty/out of bounds): put a wall
            bool neighborOccupied = neighbor is { IsOccupied: true };
            if (!neighborOccupied)
            {
                ApplyWall(cell, direction, true);
                return;
            }
    
            // Interior of the same room: no wall
            bool bothRooms = cell.Type == CellType.Room && neighbor.Type == CellType.Room;
            if (bothRooms && cell.RoomID == neighbor.RoomID)
            {
                ApplyWall(cell, direction, false);
                return;
            }

            // Different rooms: check if door exists
            if (bothRooms && cell.RoomID != neighbor.RoomID)
            {
                bool hasDoor = HasDoorBetween(position, neighborPosition);
                ApplyWall(cell, direction, !hasDoor);
                return;
            }
    
            // If two corridors are next to each other, don't have any walls between them
            bool corridorEdge = cell.Type == CellType.Corridor && neighbor.Type == CellType.Corridor;
            if (corridorEdge)
            {
                ApplyWall(cell, direction, false);
                return;
            }
    
            // Room edge: check for existing doors
            bool isRoomEdge = cell.Type == CellType.Room || neighbor.Type == CellType.Room;
            if (isRoomEdge)
            {
                bool hasDoor = HasDoorBetween(position, neighborPosition);
                ApplyWall(cell, direction, !hasDoor);
                return;
            }

            ApplyWall(cell, direction, false);
        }

        /// <summary>
        /// Updates the specified wall direction of a dungeon cell to be either present or absent
        /// based on the provided state
        /// </summary>
        /// <param name="cell">
        /// The dungeon cell to which the wall modification will be applied
        /// </param>
        /// <param name="direction">
        /// The direction of the wall to modify, relative to the cell
        /// </param>
        /// <param name="on">
        /// A boolean value indicating whether the wall should be present (true) or absent (false)
        /// </param>
        private void ApplyWall(DungeonCell cell, Direction direction, bool on)
        {
            switch (direction)
            {
                case Direction.North:
                    cell.HasWallNorth = on;
                    break;
                case Direction.South:
                    cell.HasWallSouth = on;
                    break;
                case Direction.East:
                    cell.HasWallEast = on;
                    break;
                case Direction.West:
                    cell.HasWallWest = on;
                    break;
            }
        }

        /// <summary>
        /// Determines if there is a door between the specified positions in the dungeon grid
        /// </summary>
        /// <param name="a">
        /// The first position to check, typically representing the "outside" (corridor)
        /// </param>
        /// <param name="b">
        /// The second position to check, typically representing the "inside" (room)
        /// </param>
        /// <returns>
        /// True if a door exists between the two positions; otherwise, false
        /// </returns>
        private bool HasDoorBetween(Vector2Int a, Vector2Int b)
        {
            // Get the direction from the corridor 'outside' toward the room' inside'
            Vector2Int direction = new Vector2Int(
                Mathf.Clamp(b.x - a.x, -1, 1),
                Mathf.Clamp(b.y - a.y, -1, 1)
            );

            // Get the facing direction of the door
            Direction facing = Direction.North;
            if (direction == Vector2Int.up) facing = Direction.North;
            if (direction == Vector2Int.down) facing = Direction.South;
            if (direction == Vector2Int.right) facing = Direction.East;
            if (direction == Vector2Int.left) facing = Direction.West;

            // Iterate through each room
            foreach (RoomData room in Rooms)
            {
                // Iterate through each door position
                for (int i = 0; i < room.DoorPositions.Count; i++)
                {
                    // Exit case - if there is a door at the current position with the same facing orientation
                    if (room.DoorPositions[i] == a && room.DoorDirections[i] == facing) return true;
                    
                    // Exit case - Reverse check (in case from iterating from inside to outside)
                    if(room.DoorPositions[i] == b && room.DoorDirections[i] == Opposite(facing)) return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Returns the opposite direction of the given directional input
        /// </summary>
        /// <param name="direction">
        /// The directional input for which the opposite is to be determined
        /// </param>
        /// <returns>
        /// The direction opposite to the input direction
        /// </returns>
        private Direction Opposite(Direction direction)
        {
            return direction switch
            {
                Direction.North => Direction.South,
                Direction.South => Direction.North,
                Direction.East => Direction.West,
                Direction.West => Direction.East,
                _ => direction
            };
        }
    }
}