using System.Collections.Generic;
using UnityEngine;

namespace Didionysymus.DungeonGeneration.LSystem
{
    /// <summary>
    /// A turtle that walks through the L-system string
    /// and creates spatial dungeon data
    /// </summary>
    public class DungeonTurtle
    {
        private class TurtleState
        {
            public Vector2Int Position;
            public Direction Facing;
            public int FloorLevel;

            public TurtleState(Vector2Int position, Direction facing, int floorLevel)
            {
                Position = position;
                Facing = facing;
                FloorLevel = floorLevel;
            }
            
            public TurtleState Clone() => new TurtleState(Position, Facing, FloorLevel);
        }

        private TurtleState _currentState;
        private readonly Stack<TurtleState> _stateStack;
        private readonly DungeonConfig _config;
        private readonly LSystemGrammar _grammar;

        private int _roomIDCounter = 0;
        private int _currentFloor = 0;
        
        public Dictionary<Vector2Int, DungeonCell> Grid { get; private set; }
        public List<RoomData> Rooms { get; private set; }

        public DungeonTurtle(DungeonConfig config, LSystemGrammar grammar)
        {
            // Set parameters
            _config = config;
            _grammar = grammar;
            
            // Initialize data structures
            _stateStack = new Stack<TurtleState>();
            Grid = new Dictionary<Vector2Int, DungeonCell>();
            Rooms = new List<RoomData>();

            // Start at the center of the grid, facing north
            Vector2Int startPosition = _config.MaxGridSize / 2;
            _currentState = new TurtleState(startPosition, Direction.North, 0);
        }

        /// <summary>
        /// Interprets an L-system string and processes each symbol to construct the dungeon layout
        /// by following predefined dungeon generation rules
        /// </summary>
        /// <param name="lSystemString">
        /// The string generated by the L-system that encodes the sequence of actions for the turtle
        /// to perform, such as moving, turning, or creating dungeon structures.
        /// </param>
        public void Walkthrough(string lSystemString)
        {
            // Process each symbol in the string
            foreach (char symbol in lSystemString)
            {
                ProcessSymbol(symbol);
            }

            // Ensure all rooms are connected
            EnsureConnectivity();
            
            // After interpretation, build walls
            CreateDoors();
            BuildWalls();
        }

        /// <summary>
        /// Processes a symbol from the L-system string to determine the appropriate dungeon
        /// generation action; each symbol represents a specific action, such as creating a
        /// room, adding a corridor, or changing the direction of the turtle
        /// </summary>
        /// <param name="symbol">
        /// A character from the L-system string that defines dungeon generation actions. For example,
        /// 'S' creates a Start room, 'R' creates a Standard room, '+' turns the turtle right,
        /// and '[' initiates a branch by saving the current state.
        /// </param>
        private void ProcessSymbol(char symbol)
        {
            switch (symbol)
            {
                // Start room
                case 'S':
                    CreateRoom(RoomType.Start);
                    break;
                
                // Standard room
                case 'R':
                    CreateRoom(RoomType.Standard);
                    break;
                
                // Boss room
                case 'B':
                    CreateRoom(RoomType.Boss);
                    break;
                
                // Treasure room
                case 'T':
                    CreateRoom(RoomType.Treasure);
                    break;
                
                // Safe room
                case 'F':
                    CreateRoom(RoomType.Safe);
                    break;
                
                // Corridor
                case 'C':
                    CreateCorridor();
                    break;
                
                // Start branch
                case '[':
                    _stateStack.Push(_currentState.Clone());
                    break;
                
                // End branch
                case ']':
                    if (_stateStack.Count > 0)
                    {
                        _currentState = _stateStack.Pop();
                    }
                    break;
                
                // Turn right
                case '+':
                    TurnRight();
                    break;
                
                // Turn left
                case '-':
                    TurnLeft();
                    break;
                
                // Stairs up
                case '^':
                    MoveUpOneFloor(_currentState.Position);
                    break;
                
                case 'v':
                    MoveDownOneFloor(_currentState.Position);
                    break;
            }
        }

        /// <summary>
        /// Creates a room with specific properties based on the specified room type;
        /// the size and position of the room are determined according to the dungeon
        /// configuration and constraints; we adjust the room dimensions for
        /// special room types and add the room's data to the dungeon layout,
        /// including marking its occupied cells, defining its door positions,
        /// and repositioning the turtle to the exit point of the newly created room
        /// </summary>
        /// <param name="type">
        /// The type of the room to create; determines the size and properties
        /// of the room, such as being a Boss room, Treasure room, or Standard room.
        /// </param>
        private void CreateRoom(RoomType type)
        {
            Vector2Int size = _grammar.GetRandomRoomSize();

            // Adjust size based on room type
            switch (type)
            {
                // Special rooms should be larger
                case RoomType.Boss:
                    size = new Vector2Int(
                        Mathf.Max(size.x, _config.MaxRoomSize.x - 1),
                        Mathf.Max(size.y, _config.MaxRoomSize.y - 1)
                    );
                    break;
                
                case RoomType.Treasure:
                case RoomType.Safe:
                    size = new Vector2Int(
                        Mathf.Max(size.x, (_config.MinRoomSize.x + _config.MaxRoomSize.x) / 2),
                        Mathf.Max(size.y, (_config.MinRoomSize.y + _config.MaxRoomSize.y) / 2)
                    );
                    break;
            }

            Vector2Int roomPosition = FindValidRoomPosition(size);

            // Exit case - this room is not valid
            if (roomPosition == Vector2Int.one * -1000)
            {
                Debug.LogWarning($"Failed to place {type} room of size {size} at " +
                                 $"{_currentState.Position} facing {_currentState.Facing}"
                );
                return;
            }
            
            // Create room data
            RoomData room = new RoomData(_roomIDCounter++, type, roomPosition, size, _currentFloor);
            Rooms.Add(room);
            
            // Mark cells as occupied
            foreach (Vector2Int cellPosition in room.OccupiedCells)
            {
                DungeonCell cell = GetOrCreateCell(cellPosition);
                cell.Type = CellType.Room;
                cell.IsOccupied = true;
                cell.RoomID = room.RoomID;
                cell.FloorLevel = room.FloorLevel;
            }
            
            // Move turtle to the exit point of the room
            Vector2Int exitPoint = GetRoomExitPoint(room);
            _currentState.Position = exitPoint;
        }

        /// <summary>
        /// Creates a corridor of random length starting from the current position of the turtle,
        /// extending in the direction the turtle is currently facing; the corridor is built one
        /// segment at a time until reaching the maximum allowed length, encountering a room, or
        /// exceeding the boundaries of the grid
        /// </summary>
        private void CreateCorridor()
        {
            int length = _grammar.GetRandomCorridorLength();
            bool connectedToSomething = false;
    
            for (int step = 0; step < length; step++)
            {
                Vector2Int nextPos = MoveForward(_currentState.Position, _currentState.Facing);
        
                // Check bounds
                if (!IsInBounds(nextPos)) break;
        
                DungeonCell nextCell = GetOrCreateCell(nextPos);
        
                // If we hit a room, we've connected - stop
                if (nextCell.Type == CellType.Room)
                {
                    connectedToSomething = true;
                    break;
                }
        
                // If we hit another corridor, we've connected - continue a bit more then stop
                if (nextCell.Type == CellType.Corridor)
                {
                    connectedToSomething = true;
                    // Continue for 1-2 more steps to ensure good overlap
                    if (step < length - 2)
                    {
                        _currentState.Position = nextPos;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
        
                // Mark as corridor if empty
                if (nextCell.Type == CellType.Empty)
                {
                    nextCell.Type = CellType.Corridor;
                    nextCell.IsOccupied = true;
                    nextCell.FloorLevel = _currentFloor;
                }
        
                _currentState.Position = nextPos;
        
                // Check if we're adjacent to anything
                if (IsAdjacentToOccupied(nextPos))
                {
                    connectedToSomething = true;
                }
            }
    
            // If we didn't connect to anything, try to extend toward nearest occupied cell
            if (!connectedToSomething)
            {
                ExtendCorridorToConnect();
            }
        }
        
        private bool IsAdjacentToOccupied(Vector2Int position)
        {
            Vector2Int[] neighbors = {
                position + Vector2Int.up,
                position + Vector2Int.down,
                position + Vector2Int.left,
                position + Vector2Int.right
            };
            
            foreach (var neighbor in neighbors)
            {
                if (Grid.TryGetValue(neighbor, out DungeonCell cell) && cell.IsOccupied)
                {
                    return true;
                }
            }
            
            return false;
        }

        // Add method to extend corridor toward nearest occupied area
        private void ExtendCorridorToConnect()
        {
            Vector2Int currentPos = _currentState.Position;
            Vector2Int? nearestOccupied = FindNearestOccupiedCell(currentPos, 10);
            
            if (nearestOccupied.HasValue)
            {
                // Create a simple path toward the nearest occupied cell
                Vector2Int target = nearestOccupied.Value;
                
                // Move horizontally first
                while (currentPos.x != target.x && IsInBounds(currentPos))
                {
                    currentPos.x += (target.x > currentPos.x) ? 1 : -1;
                    
                    DungeonCell cell = GetOrCreateCell(currentPos);
                    if (cell.Type == CellType.Empty)
                    {
                        cell.Type = CellType.Corridor;
                        cell.IsOccupied = true;
                        cell.FloorLevel = _currentFloor;
                    }
                    else if (cell.IsOccupied)
                    {
                        break; // We've connected!
                    }
                }
                
                // Then move vertically
                while (currentPos.y != target.y && IsInBounds(currentPos))
                {
                    currentPos.y += (target.y > currentPos.y) ? 1 : -1;
                    
                    DungeonCell cell = GetOrCreateCell(currentPos);
                    if (cell.Type == CellType.Empty)
                    {
                        cell.Type = CellType.Corridor;
                        cell.IsOccupied = true;
                        cell.FloorLevel = _currentFloor;
                    }
                    else if (cell.IsOccupied)
                    {
                        break; // We've connected!
                    }
                }
                
                _currentState.Position = currentPos;
            }
        }

        // Add helper to find nearest occupied cell
        private Vector2Int? FindNearestOccupiedCell(Vector2Int from, int maxDistance)
        {
            for (int radius = 1; radius <= maxDistance; radius++)
            {
                for (int dx = -radius; dx <= radius; dx++)
                {
                    for (int dy = -radius; dy <= radius; dy++)
                    {
                        if (Mathf.Abs(dx) != radius && Mathf.Abs(dy) != radius) continue;
                        
                        Vector2Int checkPos = from + new Vector2Int(dx, dy);
                        if (Grid.TryGetValue(checkPos, out DungeonCell cell) && cell.IsOccupied)
                        {
                            return checkPos;
                        }
                    }
                }
            }
            
            return null;
        }
        
        private void EnsureConnectivity()
        {
            if (Rooms.Count <= 1) return;
            
            // Find all connected components
            HashSet<int> visitedRooms = new HashSet<int>();
            List<List<int>> components = new List<List<int>>();
            
            foreach (var room in Rooms)
            {
                if (!visitedRooms.Contains(room.RoomID))
                {
                    List<int> component = new List<int>();
                    FloodFillRooms(room.RoomID, visitedRooms, component);
                    components.Add(component);
                }
            }
            
            // If we have multiple components, connect them
            if (components.Count > 1)
            {
                // Connect each component to the first (main) component
                for (int i = 1; i < components.Count; i++)
                {
                    ConnectComponents(components[0], components[i]);
                }
            }
        }

        private void FloodFillRooms(int roomId, HashSet<int> visited, List<int> component)
        {
            if (visited.Contains(roomId)) return;
            
            visited.Add(roomId);
            component.Add(roomId);
            
            RoomData room = Rooms.Find(r => r.RoomID == roomId);
            if (room == null) return;
            
            // Check all cells adjacent to this room
            foreach (var cellPos in room.OccupiedCells)
            {
                Vector2Int[] neighbors = {
                    cellPos + Vector2Int.up,
                    cellPos + Vector2Int.down,
                    cellPos + Vector2Int.left,
                    cellPos + Vector2Int.right
                };
                
                foreach (var neighbor in neighbors)
                {
                    if (Grid.TryGetValue(neighbor, out DungeonCell neighborCell))
                    {
                        // If it's a corridor, trace where it leads
                        if (neighborCell.Type == CellType.Corridor)
                        {
                            HashSet<int> reachableRooms = TraceCorridorToRooms(neighbor);
                            foreach (int reachableRoom in reachableRooms)
                            {
                                FloodFillRooms(reachableRoom, visited, component);
                            }
                        }
                        // If it's another room, add it
                        else if (neighborCell.Type == CellType.Room && neighborCell.RoomID != roomId)
                        {
                            FloodFillRooms(neighborCell.RoomID, visited, component);
                        }
                    }
                }
            }
        }

        private HashSet<int> TraceCorridorToRooms(Vector2Int startPos)
        {
            HashSet<int> reachableRooms = new HashSet<int>();
            HashSet<Vector2Int> visitedCells = new HashSet<Vector2Int>();
            Queue<Vector2Int> toVisit = new Queue<Vector2Int>();
            
            toVisit.Enqueue(startPos);
            
            while (toVisit.Count > 0)
            {
                Vector2Int current = toVisit.Dequeue();
                if (visitedCells.Contains(current)) continue;
                visitedCells.Add(current);
                
                if (!Grid.TryGetValue(current, out DungeonCell cell)) continue;
                
                if (cell.Type == CellType.Room)
                {
                    reachableRooms.Add(cell.RoomID);
                }
                else if (cell.Type == CellType.Corridor)
                {
                    // Continue tracing through corridors
                    Vector2Int[] neighbors = {
                        current + Vector2Int.up,
                        current + Vector2Int.down,
                        current + Vector2Int.left,
                        current + Vector2Int.right
                    };
                    
                    foreach (var neighbor in neighbors)
                    {
                        if (!visitedCells.Contains(neighbor))
                        {
                            toVisit.Enqueue(neighbor);
                        }
                    }
                }
            }
            
            return reachableRooms;
        }

        private void ConnectComponents(List<int> component1, List<int> component2)
        {
            // Find closest pair of rooms between components
            RoomData room1 = null;
            RoomData room2 = null;
            float minDistance = float.MaxValue;
            
            foreach (int id1 in component1)
            {
                RoomData r1 = Rooms.Find(r => r.RoomID == id1);
                if (r1 == null) continue;
                
                foreach (int id2 in component2)
                {
                    RoomData r2 = Rooms.Find(r => r.RoomID == id2);
                    if (r2 == null) continue;
                    
                    float dist = Vector2Int.Distance(r1.GetCenter(), r2.GetCenter());
                    if (dist < minDistance)
                    {
                        minDistance = dist;
                        room1 = r1;
                        room2 = r2;
                    }
                }
            }
            
            if (room1 != null)
            {
                // Create a corridor between them
                CreateDirectCorridor(room1.GetCenter(), room2.GetCenter());
            }
        }

        private void CreateDirectCorridor(Vector2Int from, Vector2Int to)
        {
            Vector2Int current = from;
            
            // Create L-shaped corridor (horizontal then vertical)
            while (current.x != to.x)
            {
                current.x += (to.x > current.x) ? 1 : -1;
                
                DungeonCell cell = GetOrCreateCell(current);
                if (cell.Type == CellType.Empty)
                {
                    cell.Type = CellType.Corridor;
                    cell.IsOccupied = true;
                    cell.FloorLevel = _currentFloor;
                }
            }
            
            while (current.y != to.y)
            {
                current.y += (to.y > current.y) ? 1 : -1;
                
                DungeonCell cell = GetOrCreateCell(current);
                if (cell.Type == CellType.Empty)
                {
                    cell.Type = CellType.Corridor;
                    cell.IsOccupied = true;
                    cell.FloorLevel = _currentFloor;
                }
            }
        }

        /// <summary>
        /// Finds a valid position on the grid to place a room of the specified size
        /// based on the current state and dungeon constraints
        /// </summary>
        /// <param name="size">The dimensions of the room to be placed</param>
        /// <returns>
        /// A valid position as a Vector2Int if the room can be placed without
        /// overlapping or exceeding the grid bounds; otherwise, returns a
        /// marker Vector2Int.one * -1000 to indicate an invalid position
        /// </returns>
        private Vector2Int FindValidRoomPosition(Vector2Int size)
        {
            // Try the current position first
            Vector2Int centerOffset = new Vector2Int(size.x / 2, size.y / 2);
            Vector2Int testPosition = _currentState.Position - centerOffset;

            // Exit case - this position is valid
            if (CanPlaceRoom(testPosition, size)) return testPosition;

            for (int radius = 1; radius <= 15; radius++)
            {
                // Try positions in a square ring around the current position
                for (int dx = -radius; dx <= radius; dx++)
                {
                    for (int dy = -radius; dy <= radius; dy++)
                    {
                        // Only check the perimeter of the square
                        if(Mathf.Abs(dx) != radius && Mathf.Abs(dy) != radius) continue;
                        
                        testPosition = _currentState.Position + new Vector2Int(dx, dy) - centerOffset;

                        if (CanPlaceRoom(testPosition, size)) return testPosition;
                    }
                }
            }

            // If there's still no valid position, try with a smaller room
            if (size.x > _config.MinRoomSize.x || size.y > _config.MinRoomSize.y)
            {
                Vector2Int smallerSize = new Vector2Int(
                    Mathf.Max(_config.MinRoomSize.x, size.x - 1),
                    Mathf.Max(_config.MinRoomSize.y, size.y - 1)
                );
                return FindValidRoomPosition(smallerSize);
            }
            
            // Invalid position marker
            return Vector2Int.one * -1000;
        }

        /// <summary>
        /// Determines whether a room can be placed at a specified position with a given size on the dungeon grid
        /// </summary>
        /// <param name="position">The starting position on the grid where the room is to be placed</param>
        /// <param name="size">The dimensions of the room to be placed</param>
        /// <returns>
        /// True if the room can be placed at the specified position without
        /// overlapping other rooms or exceeding grid bounds; otherwise false
        /// </returns>
        private bool CanPlaceRoom(Vector2Int position, Vector2Int size)
        {
            // Exit case - the room does not fit within grid bounds
            if (position.x < 0 || position.y < 0 ||
                position.x + size.x >= _config.MaxGridSize.x ||
                position.y + size.y >= _config.MaxGridSize.y)
            {
                Debug.Log($"Room at {position} with size {size} does not fit within grid bounds");
                return false;
            }
            
            // Check if any cell is already occupied by a room
            // If buffer ON: check ring around the footprint; if OFF: only check the interior
            for (int dx = -(_config.OneCellBuffer ? 1 : 0); dx < size.x + (_config.OneCellBuffer ? 1 : 0); dx++)
            {
                for (int dz = -(_config.OneCellBuffer ? 1 : 0); dz < size.y + (_config.OneCellBuffer ? 1 : 0); dz++)
                {
                    Vector2Int targetPosition = position + new Vector2Int(dx, dz);
                    DungeonCell cell = GetCell(targetPosition);
                    bool inside = dx >= 0 && dx < size.x && dz >= 0 && dz < size.y;

                    if (_config.OneCellBuffer)
                    {
                        if (cell is { IsOccupied: true }) return false;
                    }
                    else
                    {
                        if (inside && cell is { IsOccupied: true }) return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Determines the exit point of a room based on the current facing direction of the turtle
        /// </summary>
        /// <param name="room">The room for which the exit point is being calculated</param>
        /// <returns>The grid position of the room's exit point</returns>
        private Vector2Int GetRoomExitPoint(RoomData room)
        {
            // Get the edge position based on the turtle's facing direction
            Vector2Int center = room.GetCenter();

            switch (_currentState.Facing)
            {
                case Direction.North:
                    return new Vector2Int(center.x, room.GridPosition.y + room.Size.y);
                
                case Direction.South:
                    return new Vector2Int(center.x, room.GridPosition.y - 1);
                
                case Direction.East:
                    return new Vector2Int(room.GridPosition.x + room.Size.x, center.y);
                
                case Direction.West:
                    return new Vector2Int(room.GridPosition.x - 1, center.y);
                
                default:
                    return center;
            }
        }

        /// <summary>
        /// Updates the turtle's current facing direction by rotating 90 degrees clockwise
        /// </summary>
        private void TurnRight()
        {
            _currentState.Facing = _currentState.Facing switch
            {
                Direction.North => Direction.East,
                Direction.East => Direction.South,
                Direction.South => Direction.West,
                Direction.West => Direction.North,
                _ => _currentState.Facing
            };
        }

        /// <summary>
        /// Updates the turtle's current facing direction by rotating 90 degrees counterclockwise
        /// </summary>
        private void TurnLeft()
        {
            _currentState.Facing = _currentState.Facing switch
            {
                Direction.North => Direction.West,
                Direction.West => Direction.South,
                Direction.South => Direction.East,
                Direction.East => Direction.North,
                _ => _currentState.Facing
            };
        }

        /// <summary>
        /// Moves the dungeon generation context up by one floor, creating a staircase at the current position
        /// and preparing the corresponding landing cell on the new floor
        /// </summary>
        /// <param name="position">
        /// The current position of the turtle within the dungeon grid, which is used as the base for the staircase
        /// and the landing on the next floor
        /// </param>
        private void MoveUpOneFloor(Vector2Int position)
        {
            // Exit case - we are already on the top floor
            if (_currentFloor >= _config.Floors - 1) return;
            
            // Mark base as stairs
            DungeonCell baseCell = GetOrCreateCell(position);
            baseCell.Type = CellType.Stairs;
            baseCell.IsOccupied = true;
            baseCell.FloorLevel = _currentFloor;
            
            // Go up a floor
            _currentFloor += 1;
            _currentState.FloorLevel = _currentFloor;
            
            // Ensure landing cell exists on the new floor
            DungeonCell landingCell = GetOrCreateCell(position);
            landingCell.Type = CellType.StairLanding;
            landingCell.IsOccupied = false;
            landingCell.FloorLevel = _currentFloor;
        }

        /// <summary>
        /// Moves the dungeon turtle down one floor, updating the current floor level and creating
        /// the necessary stair and landing cells at the specified position
        /// </summary>
        /// <param name="position">
        /// The grid position where the stairs and landing cells will be created during the floor transition
        /// </param>
        private void MoveDownOneFloor(Vector2Int position)
        {
            // Exit case - we are already on the bottom floor
            if (_currentFloor <= 0 ) return;
            
            // Mark base as stairs
            DungeonCell baseCell = GetOrCreateCell(position);
            baseCell.Type = CellType.Stairs;
            baseCell.IsOccupied = true;
            baseCell.FloorLevel = _currentFloor;
            
            // Go up a floor
            _currentFloor -= 1;
            _currentState.FloorLevel = _currentFloor;
            
            // Ensure landing cell exists on the new floor
            DungeonCell landingCell = GetOrCreateCell(position);
            landingCell.Type = CellType.StairLanding;
            landingCell.IsOccupied = false;
            landingCell.FloorLevel = _currentFloor;
        }

        /// <summary>
        /// Calculates the new position by moving forward in the specified direction from the given position
        /// </summary>
        /// <param name="position">The current grid position of the turtle</param>
        /// <param name="direction">The direction in which the turtle is moving</param>
        /// <returns>The new grid position after moving forward in the specified direction</returns>
        private Vector2Int MoveForward(Vector2Int position, Direction direction)
        {
            return direction switch
            {
                Direction.North => position + Vector2Int.up,
                Direction.South => position + Vector2Int.down,
                Direction.East => position + Vector2Int.right,
                Direction.West => position + Vector2Int.left,
                _ => position
            };
        }

        /// <summary>
        /// Determines whether the specified position is within the bounds of the dungeon grid
        /// </summary>
        /// <param name="position">The grid position to check</param>
        /// <returns>True if the position is within the bounds; otherwise, false</returns>
        private bool IsInBounds(Vector2Int position)
        {
            return position.x >= 0 && position.x < _config.MaxGridSize.x &&
                   position.y >= 0 && position.y < _config.MaxGridSize.y;
        }

        /// <summary>
        /// Retrieves an existing DungeonCell at the specified position or creates a new one if it doesn't exist
        /// </summary>
        /// <param name="position">The grid position of the cell to retrieve or create</param>
        /// <returns>The DungeonCell at the specified position</returns>
        private DungeonCell GetOrCreateCell(Vector2Int position)
        {
            // Add the cell to the grid if it doesn't exist
            if(!Grid.ContainsKey(position))
                Grid.Add(position, new DungeonCell(position, _currentFloor));

            // Return the cell at the given position
            return Grid[position];
        }

        /// <summary>
        /// Retrieves a DungeonCell from the grid based on the specified position
        /// </summary>
        /// <param name="position">The grid position of the cell to retrieve</param>
        /// <returns>The DungeonCell at the specified position, or null if no cell exists</returns>
        private DungeonCell GetCell(Vector2Int position)
        {
            return Grid.GetValueOrDefault(position);
        }

        /// <summary>
        /// Constructs walls for the dungeon by iterating through all cells in the grid
        /// and determining the presence of walls based on the occupancy of neighboring cells
        /// </summary>
        public void BuildWalls()
        {
            // Iterate through each cell in the grid
            foreach (KeyValuePair<Vector2Int, DungeonCell> kvp in Grid)
            {
                DungeonCell cell = kvp.Value;

                // Exit case - the cell is not occupied
                if (!cell.IsOccupied) continue;
                
                // Get the cell position
                Vector2Int position = cell.GridPosition;
                
                SetWall(Direction.North, position, cell);
                SetWall(Direction.South, position, cell);
                SetWall(Direction.East, position, cell);
                SetWall(Direction.West, position, cell);
            }
        }

        private void CreateDoors()
        {
            // Clear existing door data
            foreach (RoomData room in Rooms)
            {
                room.DoorPositions.Clear();
                room.DoorDirections.Clear();
            }

            foreach (RoomData room in Rooms)
            {
                Dictionary<Direction, List<Vector2Int>> wallSegments = GetRoomWallSegments(room);

                foreach (KeyValuePair<Direction, List<Vector2Int>> kvp in wallSegments)
                {
                    Direction wallDirection = kvp.Key;
                    List<Vector2Int> wallCells = kvp.Value;

                    if (wallCells.Count == 0) continue;
                    
                    // Find corridors or other rooms adjacent to this cell
                    List<Vector2Int> validDoorPositions = new List<Vector2Int>();

                    foreach (Vector2Int wallCell in wallCells)
                    {
                        Vector2Int outsidePosition = GetAdjacentPosition(wallCell, wallDirection);
                        if (!Grid.TryGetValue(outsidePosition, out DungeonCell outsideCell)) continue;

                        if (outsideCell.IsOccupied && (outsideCell.Type == CellType.Corridor ||
                                                       outsideCell.Type == CellType.Room &&
                                                       outsideCell.RoomID != room.RoomID))
                        {
                            validDoorPositions.Add(wallCell);
                        }
                    }

                    if (validDoorPositions.Count > 0)
                    {
                        PlaceCenteredDoor(room, wallDirection, validDoorPositions);
                    }
                }
            }
        }

        private Dictionary<Direction, List<Vector2Int>> GetRoomWallSegments(RoomData room)
        {
            Dictionary<Direction, List<Vector2Int>> segments = new Dictionary<Direction, List<Vector2Int>>
            {
                { Direction.North, new List<Vector2Int>() },
                { Direction.South, new List<Vector2Int>() },
                { Direction.East, new List<Vector2Int>() },
                { Direction.West, new List<Vector2Int>() }
            };
            
            // North wall
            for (int x = 0; x < room.Size.x; x++)
            {
                segments[Direction.North].Add(room.GridPosition + new Vector2Int(x, room.Size.y - 1));
            }
            
            // South wall
            for (int x = 0; x < room.Size.x; x++)
            {
                segments[Direction.South].Add(room.GridPosition + new Vector2Int(x, 0));
            }
            
            // East wall
            for (int y = 0; y < room.Size.y; y++)
            {
                segments[Direction.East].Add(room.GridPosition + new Vector2Int(room.Size.x - 1, y));
            }
            
            // West wall
            for (int y = 0; y < room.Size.y; y++)
            {
                segments[Direction.West].Add(room.GridPosition + new Vector2Int(0, y));
            }

            return segments;
        }

        private void PlaceCenteredDoor(RoomData room, Direction wallDirection, List<Vector2Int> validPositions)
        {
            // Check if any position on this wall already has a door to ANY adjacent area
            foreach (Vector2Int pos in validPositions)
            {
                Vector2Int outsidePos = GetAdjacentPosition(pos, wallDirection);
                if (HasDoorBetween(outsidePos, pos))
                {
                    return; // A door already exists on this wall
                }
            }
            
            // Skip corners if possible
            List<Vector2Int> nonCornerPositions = new List<Vector2Int>();
            
            foreach (Vector2Int position in validPositions)
            {
                bool isCorner = IsCornerPosition(room, position);
                if(!isCorner) nonCornerPositions.Add(position);
            }
            
            // Use non-corner positions if available
            List<Vector2Int> positionsToUse = nonCornerPositions.Count > 0 ? nonCornerPositions : validPositions;
            
            // Find continuous segments
            List<List<Vector2Int>> segments = FindContinuousSegments(positionsToUse, wallDirection);
            
            // Place only one door for the entire wall
            if (segments.Count > 0)
            {
                // Find the longest segment
                List<Vector2Int> longestSegment = segments[0];
                foreach (var segment in segments)
                {
                    if (segment.Count > longestSegment.Count)
                        longestSegment = segment;
                }
                
                if (longestSegment.Count > 0)
                {
                    // Get the center position of the longest segment
                    int centerIndex = longestSegment.Count / 2;
                    Vector2Int doorPosition = longestSegment[centerIndex];
                    
                    // Add the door (outside position pointing into the room)
                    Vector2Int outsidePos = GetAdjacentPosition(doorPosition, wallDirection);
                    
                    // Double-check one more time before adding
                    if (!HasDoorBetween(outsidePos, doorPosition))
                    {
                        room.DoorPositions.Add(outsidePos);
                        room.DoorDirections.Add(Opposite(wallDirection));
                    }
                }
            }
        }
        
        private bool WallAlreadyHasConnectionTo(RoomData room, Direction wallDirection, List<Vector2Int> positions)
        {
            // Get what's on the other side of this wall
            if (positions.Count == 0) return false;
    
            Vector2Int samplePos = GetAdjacentPosition(positions[0], wallDirection);
            if (!Grid.TryGetValue(samplePos, out DungeonCell outsideCell)) return false;
    
            // Check if we already have a door to this specific area
            for (int i = 0; i < room.DoorPositions.Count; i++)
            {
                if (room.DoorDirections[i] == Opposite(wallDirection))
                {
                    // Check if this door leads to the same room/corridor
                    Vector2Int existingDoorPos = room.DoorPositions[i];
                    if (Grid.TryGetValue(existingDoorPos, out DungeonCell existingDoorCell))
                    {
                        // If both lead to corridors or to the same room, we already have a connection
                        if ((outsideCell.Type == CellType.Corridor && existingDoorCell.Type == CellType.Corridor) ||
                            (outsideCell.RoomID == existingDoorCell.RoomID && outsideCell.RoomID != -1))
                        {
                            return true;
                        }
                    }
                }
            }
    
            return false;
        }

        private bool IsCornerPosition(RoomData room, Vector2Int position)
        {
            Vector2Int relativePos = position - room.GridPosition;
    
            bool isXEdge = (relativePos.x == 0 || relativePos.x == room.Size.x - 1);
            bool isYEdge = (relativePos.y == 0 || relativePos.y == room.Size.y - 1);
    
            return isXEdge && isYEdge;
        }
        
        private List<List<Vector2Int>> FindContinuousSegments(List<Vector2Int> positions, Direction wallDirection)
        {
            if (positions.Count == 0) return new List<List<Vector2Int>>();
    
            // Sort positions based on wall direction
            positions.Sort((a, b) => 
            {
                if (wallDirection == Direction.North || wallDirection == Direction.South)
                    return a.x.CompareTo(b.x);
                else
                    return a.y.CompareTo(b.y);
            });
    
            List<List<Vector2Int>> segments = new List<List<Vector2Int>>();
            List<Vector2Int> currentSegment = new List<Vector2Int> { positions[0] };
    
            for (int i = 1; i < positions.Count; i++)
            {
                int distance = (wallDirection == Direction.North || wallDirection == Direction.South) 
                    ? Mathf.Abs(positions[i].x - positions[i-1].x)
                    : Mathf.Abs(positions[i].y - positions[i-1].y);
        
                if (distance == 1)
                {
                    currentSegment.Add(positions[i]);
                }
                else
                {
                    segments.Add(new List<Vector2Int>(currentSegment));
                    currentSegment = new List<Vector2Int> { positions[i] };
                }
            }
    
            segments.Add(currentSegment);
            return segments;
        }
        
        private Vector2Int GetAdjacentPosition(Vector2Int pos, Direction direction)
        {
            return direction switch
            {
                Direction.North => pos + Vector2Int.up,
                Direction.South => pos + Vector2Int.down,
                Direction.East => pos + Vector2Int.right,
                Direction.West => pos + Vector2Int.left,
                _ => pos
            };
        }

        private void SetWall(Direction direction, Vector2Int position, DungeonCell cell)
        {
            Vector2Int vectorDirection = direction switch
            {
                Direction.North => Vector2Int.up,
                Direction.South => Vector2Int.down,
                Direction.East => Vector2Int.right,
                Direction.West => Vector2Int.left,
                _ => Vector2Int.zero
            };
    
            Vector2Int neighborPosition = position + vectorDirection;
            DungeonCell neighbor = GetCell(neighborPosition);

            // If no neighbor (empty/out of bounds): put a wall
            bool neighborOccupied = neighbor is { IsOccupied: true };
            if (!neighborOccupied)
            {
                ApplyWall(cell, direction, true);
                return;
            }
    
            // Interior of the same room: no wall
            bool bothRooms = cell.Type == CellType.Room && neighbor.Type == CellType.Room;
            if (bothRooms && cell.RoomID == neighbor.RoomID)
            {
                ApplyWall(cell, direction, false);
                return;
            }

            // Different rooms: check if door exists
            if (bothRooms && cell.RoomID != neighbor.RoomID)
            {
                bool hasDoor = HasDoorBetween(position, neighborPosition);
                ApplyWall(cell, direction, !hasDoor);
                return;
            }
    
            // If two corridors are next to each other, don't have any walls between them
            bool corridorEdge = cell.Type == CellType.Corridor && neighbor.Type == CellType.Corridor;
            if (corridorEdge)
            {
                ApplyWall(cell, direction, false);
                return;
            }
    
            // Room edge: check for existing doors
            bool isRoomEdge = cell.Type == CellType.Room || neighbor.Type == CellType.Room;
            if (isRoomEdge)
            {
                bool hasDoor = HasDoorBetween(position, neighborPosition);
                ApplyWall(cell, direction, !hasDoor);
                return;
            }

            ApplyWall(cell, direction, false);
        }

        private void ApplyWall(DungeonCell cell, Direction direction, bool on)
        {
            switch (direction)
            {
                case Direction.North:
                    cell.HasWallNorth = on;
                    break;
                case Direction.South:
                    cell.HasWallSouth = on;
                    break;
                case Direction.East:
                    cell.HasWallEast = on;
                    break;
                case Direction.West:
                    cell.HasWallWest = on;
                    break;
            }
        }

        private bool HasDoorBetween(Vector2Int a, Vector2Int b)
        {
            // Get the direction from the corridor 'outside' toward the room' inside'
            Vector2Int direction = new Vector2Int(
                Mathf.Clamp(b.x - a.x, -1, 1),
                Mathf.Clamp(b.y - a.y, -1, 1)
            );

            // Get the facing direction of the door
            Direction facing = Direction.North;
            if (direction == Vector2Int.up) facing = Direction.North;
            if (direction == Vector2Int.down) facing = Direction.South;
            if (direction == Vector2Int.right) facing = Direction.East;
            if (direction == Vector2Int.left) facing = Direction.West;

            // Iterate through each room
            foreach (RoomData room in Rooms)
            {
                // Iterate through each door position
                for (int i = 0; i < room.DoorPositions.Count; i++)
                {
                    // Exit case - if there is a door at the current position with the same facing orientation
                    if (room.DoorPositions[i] == a && room.DoorDirections[i] == facing) return true;
                    
                    // Exit case - Reverse check (in case from iterating from inside to outside)
                    if(room.DoorPositions[i] == b && room.DoorDirections[i] == Opposite(facing)) return true;
                }
            }

            return false;
        }

        private bool RoomAlreadyHasDoorOnWall(RoomData room, Direction wallSide)
        {
            for (int i = 0; i < room.DoorPositions.Count; i++)
            {
                if (room.DoorDirections[i] == wallSide) return true;
            }

            return false;
        }

        private Direction Opposite(Direction direction)
        {
            return direction switch
            {
                Direction.North => Direction.South,
                Direction.South => Direction.North,
                Direction.East => Direction.West,
                Direction.West => Direction.East,
                _ => direction
            };
        }
    }
}