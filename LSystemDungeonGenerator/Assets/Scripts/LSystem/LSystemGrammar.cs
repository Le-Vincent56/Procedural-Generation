using System.Collections.Generic;
using System.Text;
using UnityEngine;

namespace Didionysymus.DungeonGeneration.LSystem
{
    /// <summary>
    /// Represents a grammar-based implementation of an L-System for procedural dungeon generation;
    /// this class handles the creation of a string representation of a dungeon based on configurable rules,
    /// which serves as the foundation for generating dungeon layouts
    /// </summary>
    public class LSystemGrammar
    {
        private Dictionary<char, List<string>> _expansionRules;
        private readonly System.Random _random;
        private readonly DungeonConfig _config;

        public LSystemGrammar(DungeonConfig config, int seed)
        {
            _config = config;
            _random = seed == 0 ? new System.Random() : new System.Random(seed);
            InitializeRules();
        }

        /// <summary>
        /// Initializes the set of L-System expansion rules used for dungeon generation;
        /// these rules define how symbols in the L-System axiom expand during each iteration,
        /// resulting in a procedural structure for dungeons
        /// </summary>
        private void InitializeRules()
        {
            _expansionRules = new Dictionary<char, List<string>>();
            
            // Start room expands into corridors and rooms
            AddRule('S', "RC");         // Start with a room and corridor
            AddRule('S', "RC[+RC]");    // Start with a branch
            AddRule('S', "RC[-RC]");    // Start with branch
            
            // Rooms can connect to corridors
            AddRule('R', "R");      // Room stays as a room
            AddRule('R', "R");      // Add weight
            AddRule('R', "CR");     // Room to corridor to room
            AddRule('R', "RC[+R]");  // Room with a branch
            AddRule('R', "RC[-R]");  // Room with a branch
            AddRule('R', "RC[+CR]");
            AddRule('R', "RC[-CR]");
            
            // Corridors can lead to rooms or more corridors
            AddRule('C', "C");      // Single corridor segment
            AddRule('C', "C");      // Add weight
            AddRule('C', "CR");     // Corridor to room
            
            // Special room types
            AddRule('B', "B");  // Boss Room
            AddRule('T', "T");  // Treasure Room
            AddRule('F', "F");  // Safe Room
            AddRule('X', "X"); // Start room
        }

        /// <summary>
        /// Adds a new expansion rule to the grammar for procedural dungeon generation;
        /// this associates a given symbol with an expansion pattern that defines how
        /// it transforms during the dungeon generation process
        /// </summary>
        /// <param name="symbol">The character representing a specific L-System symbol</param>
        /// <param name="expansion">
        /// The string pattern to which the symbol expands, defining its transformation
        /// </param>
        private void AddRule(char symbol, string expansion)
        {
            // Add the rule to the dictionary if it doesn't exist
            if (!_expansionRules.ContainsKey(symbol))
                _expansionRules.Add(symbol, new List<string>());
            
            // Add the expansion to the list of expansions for the symbol
            _expansionRules[symbol].Add(expansion);
        }

        /// <summary>
        /// Generates a string representation of a dungeon layout based on an L-System algorithm;
        /// the generation process begins with a specified axiom and iteratively applies predefined
        /// expansion rules for a configured number of iterations; special room types may be inserted
        /// into the final result as part of the process
        /// </summary>
        /// <returns>
        /// A string representing the expanded and processed dungeon layout generated by the L-System
        /// </returns>
        public string Generate()
        {
            // Set the axiom to the custom value if it exists, otherwise use the default value
            string axiom = string.IsNullOrEmpty(_config.CustomAxiom)
                ? "S"
                : _config.CustomAxiom;
            string current = axiom;
            
            // Apply the rules for the specified number of iterations
            for (int i = 0; i < _config.Iterations; i++)
            {
                current = ApplyRules(current);
            }

            // Insert special rooms into the layout
            current = InsertSpecialRooms(current);

            return current;
        }

        /// <summary>
        /// Applies the L-System expansion rules to the given input string, replacing each symbol
        /// with its corresponding rule or keeping it unchanged if no rule exists
        /// </summary>
        /// <param name="input">The input string to process using the expansion rules</param>
        /// <returns>A new string produced by applying the expansion rules to the input string</returns>
        private string ApplyRules(string input)
        {
            StringBuilder output = new StringBuilder();

            // Iterate through each character in the input string
            foreach (char symbol in input)
            {
                // Check if the symbol is in the dictionary
                if (_expansionRules.TryGetValue(symbol, out List<string> rules))
                {
                    // Randomly select one of the rules for this symbol
                    string selectedRule = rules[_random.Next(rules.Count)];
                    output.Append(selectedRule);
                }
                else
                {
                    // If no rule exists, keep the symbol as-is
                    output.Append(symbol);
                }
            }

            return output.ToString();
        }

        /// <summary>
        /// Modifies the input L-System sequence by replacing specific Room symbols ('R')
        /// with special room types such as Boss Rooms, Treasure Rooms, and Safe Rooms;
        /// the selection and replacement of Rooms are randomized based on the provided configuration
        /// </summary>
        /// <param name="input">The L-System generated string representing the dungeon layout,
        /// using 'R' to denote Room placeholders</param>
        /// <returns>The modified dungeon layout string with specific room types ('B', 'T', 'F') inserted
        /// in place of room placeholders</returns>
        private string InsertSpecialRooms(string input)
        {
            StringBuilder output = new StringBuilder(input);
            
            // Find all 'R' positions
            List<int> roomPositions = new List<int>();
            for (int i = 0; i < output.Length; i++)
            {
                // Skip if the character is not a room
                if (output[i] != 'R') continue;
                
                // Add the position to the list
                roomPositions.Add(i);
            }
            
            // Shuffle room positions
            for (int i = roomPositions.Count - 1; i > 0; i--)
            {
                int j = _random.Next(i + 1);
                (roomPositions[i], roomPositions[j]) = (roomPositions[j], roomPositions[i]);
            }

            int positionIndex = 0;

            // Insert boss rooms
            for (int i = 0; 
                 i < _config.BossRoomCount && positionIndex < roomPositions.Count; 
                 i++, positionIndex++
            )
            {
                output[roomPositions[positionIndex]] = 'B';
            }

            // Insert treasure rooms
            for (int i = 0; 
                 i < _config.TreasureRoomCount && positionIndex < roomPositions.Count; 
                 i++, positionIndex++
            )
            {
                output[roomPositions[positionIndex]] = 'T';
            }

            // Insert safe rooms
            for (int i = 0; 
                 i < _config.SafeRoomCount && positionIndex < roomPositions.Count; 
                 i++, positionIndex++
            )
            {
                output[roomPositions[positionIndex]] = 'F';
            }

            // Set the start room
            output[roomPositions[positionIndex]] = 'X';

            return output.ToString();
        }

        /// <summary>
        /// Generates a random room size based on predefined chances and configured size parameters
        /// </summary>
        /// <returns>
        /// A Vector2Int representing the width and height of the room
        /// </returns>
        public Vector2Int GetRandomRoomSize()
        {
            // Roll a random number
            float roll = (float)_random.NextDouble();

            Vector2Int size;

            // Determine the size of the room based on the roll
            if (roll < _config.SmallRoomChance)
            {
                // Small room
                size = new Vector2Int(
                    _random.Next(_config.MinRoomSize.x, _config.MinRoomSize.x + 2),
                    _random.Next(_config.MinRoomSize.y, _config.MinRoomSize.y + 2)
                );
            } 
            else if (roll < _config.SmallRoomChance + _config.MediumRoomChance)
            {
                // Medium room
                int midX = (_config.MinRoomSize.x + _config.MaxRoomSize.x) / 2;
                int midY = (_config.MinRoomSize.y + _config.MaxRoomSize.y) / 2;
                size = new Vector2Int(
                    _random.Next(midX - 1, midX + 2),
                    _random.Next(midY - 1, midY + 2)
                );
            }
            else
            {
                // Large room
                size = new Vector2Int(
                    _random.Next(_config.MaxRoomSize.x - 2, _config.MaxRoomSize.x + 1),
                    _random.Next(_config.MaxRoomSize.y - 2, _config.MaxRoomSize.y + 1)
                );
            }

            return size;
        }

        /// <summary>
        /// Determines a random corridor length within the constraints defined
        /// by the dungeon configuration settings for minimum and maximum corridor lengths
        /// </summary>
        /// <returns>
        /// An integer representing the randomly selected length of a corridor
        /// </returns>
        public int GetRandomCorridorLength()
        {
            return _random.Next(_config.MinCorridorLength, _config.MaxCorridorLength + 1);
        }
    }
}